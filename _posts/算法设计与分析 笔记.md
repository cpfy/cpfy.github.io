# Design and Analysis of Algorithms

## Lecture1：Introduction

略

## Lecture 2: Asymptotic Notations and Recurrences

+ Asymptotic Notations（渐进记号）

  + Big-Oh
  + Big-Omega
  + Big-Theta

+ Solving Recurrences

  + Recursion tree method（递归树法）

  + Substitution method（替代法）

  + Master method and master Theorem（主方法）

    对于递推式$T(n)=aT(\lceil \frac{n}{b} \rceil)+O(n^d)$，其中$a>0, b>1,d \geq 0$，T(n)的复杂度为：
    $$
    T(n)= \left\{ \begin{array}{rcl}
    O(n^d), & if \ d>\log_ba	\\
    O(n^d \log n), & if \ d=\log_ba	\\
    O(n^{\log_ba}), & if \ d<\log_ba	\\
    \end{array}\right.
    $$
    

## Lecture 3：Maximum Contiguous Subarray Problem and Counting Inversion Problem

+ Introduction to Part I
  
+ Divide-and-conquer (D&C) ：**分治思想**
  
+ Maximum Contiguous Subarray Problem（最大连续子数组问题）

  + A brute force algorithm（暴力解法）

    $O(n^3)$

  + A data-reuse algorithm（重复利用已算出的数据）

    $O(n^2)$

  + A divide-and-conquer algorithm（分治解法）

    $O(nlogn)$

  + Kadane‘s algorithm可以降到$O(n)$

+ Counting Inversions Problem（逆序计数问题）

  + A brute force algorithm

    $O(n^2)$

  + A divide-and-conquer algorithm

    + 合并思路-1：For each element b ∈ B, binary search in A to find how many elements in A are greater than b.

      （在A、B有序条件下，对B中每个元素二分查找A中几个元素比它大）

      **复杂度：**$O(nlogn)$

    + 改进的合并思路-2：Compare ai and bj.
      If ai < bj, then ai is not inverted with any element left in B.
      If ai > bj, then bj is inverted with every element left in A.
      Append smaller element to sorted list C.

      （边scan边计数，同时新的list C可顺便sort了）

      **复杂度：**$O(n)$；算上全部的递归则为：$O(nlogn)$

## Lecture 4：Polynomial Multiplication_Quicksort

+ Polynomial Multiplication Problem（多项式乘法问题）

  + Problem definition 

  + A brute force algorithm

    正常两多项式相乘，复杂度：$O(n^2)$

  + A first divide-and-conquer algorithm

    + 设定：
      $$
      A_0(x)=a_0+a_1x+...+a_{\frac{n}{2}-1}x^{\frac{n}{2}-1}	\\
      A_1(x) = a_{\frac{n}{2}}+ a_{\frac{n}{2}+1}x+...+a_nx^{\frac{n}{2}}	\\
      A(x) = A_0(x)+A_1(x)x^{\frac{n}{2}}	\\
      Similarly, \ B(x) = B_0(x)+B_1(x)x^{\frac{n}{2}}	\\
      $$

    + 于是，$A(x)B(x) = A_0(x)B_0(x) + A_0(x)B_1(x)x^{\frac{n}{2}}+A_1(x)B_0(x)x^{\frac{n}{2}}+A_1(x)B_1(x)x^n$

    + 复杂度计算：$T(n) = 4T(n/2)+n$；$Total = O(n^2)$

  + An improved divide-and-conquer algorithm

    + 令：
      $$
      Y = (A_0+A_1)(B_0+B_1)	\\
      U = A_0B_0	\\
      Z = A_1B_1	\\
      A_0B_1+A_1B_0 = Y - U - Z
      $$

    + $Total = O(n^{log3})$

  + Analysis of the divide-and-conquer algorithm

    Fast Fourier Transform（FFT）算法可达到：$O(nlogn)$

+ Quicksort Problem（快速排序问题）

  + Basic partition 
  + Randomized partition and randomized quicksort
  + Analysis of the randomized quicksort

## Lecture 4+: Quicksort, Heapsort and Comparison-based Lower Bound for Sorting

+ Introduction to Part II

  三种均为$O(n\log n)$

+ Quicksort Problem

  + Basic partition 

  + Randomized partition and randomized quicksort

    与上面相比每次选取随机位置基准数，所需时间不依赖于输入

  + Analysis of the randomized quicksort

    计算Expection的p152页极其精彩

+ Heapsort Problem

  + Priority Queues

  + (Binary) Heap

    插入、取最小（最大）值均为$O(\log n)$

  + Heapsort

+ Lower Bound for Comparison-based Sorting

  + Objective

    可证明comparision下的排序极限是$O(n \log n)$，见p274

  + Decision Tree Model

## Lecture 5: 0-1 Knapsack and Rod Cutting Problems

### 0-1 Knapsack Problem（0-1背包）

* Problem Definition

  n个背包，价值分别$v_i$，重量分别$w_i$，重量不超过W的情况下求最大价值。

* A Bruteforce Algorithm

  $V[i,w]=max(V[i-1,w], v_i+V[i-1,w-w_i])$

  递归求解：$KnapsackSR(i,w)=max\{ KnapsackSR(i-1,w), v_i + KnapsackSR(i-1,w-w_i) \}$

  **复杂度**：$\Omega(2^n)$

* A Dynamic Programming Algorithm

  核心思想：自底向上、填表

  **复杂度**：$O(nW)$

* Analysis of DP Algorithm

### Rod Cutting Problem（钢条切割）

* Problem Definition

  一钢条，不同长度的价值$p_i$确定，切割最大价值、如何切割总价值最大。

* A Bruteforce Algorithm

  暴力的递归：$r_n=max(p_n, r_1+r_{n-1}, r_2+r_{n-2}, ..., r_{n-1}+r_1)$

  稍简化版本：$r_n=\mathop{max}\limits_{1 \leq i \leq n} (p_i+r_{n-i})$

* A Dynamic Programming Algorithm

  自底向上计算$r[n]$，对每一个$j$，i从1到$j$遍历，$q \leftarrow max(q, p[i]+r[j-i])$，共计算$j$次

  **复杂度**：$O(n^2)$

## Lecture 6: Chain Matrix Multiplication and Longest Common Subsequence Problem

### Chain Matrix Multiplication Problem（矩阵链乘法）

+ Review of Matrix Multiplication

  问题定义：$A_1A_2...A_n$矩阵序列，找到一个合适的乘法顺序（加括号）使得总运算数最小

+ The Chain Matrix Multiplication Problem

+ A Dynamic Programming Algorithm

  递推公式：$m[i,j]= \mathop{min}\limits_{i \leq k < j}(m[i,k]+m[k+1,j]+p_{i-1}p_kp_j) $

  **复杂度**：$O(n^3)$

### Longest Common Subsequence Problem（最长公共子序列）

+ Longest Common Subsequence Problem
  $$
  d_{i,j}= \left\{ \begin{array}{rcl}
  d_{i-1,j-1}+1, & if \ x_i=y_j	\\
  max\{d_{i-1,j},d_{i,j-1}\}, & if \ x_i\neq y_j	\\
  \end{array}\right.
  $$

+ Longest Common Substring Problem
  $$
  d_{i,j}= \left\{ \begin{array}{rcl}
  d_{i-1,j-1}+1, & if \ x_i=y_j	\\
  0, & if \ x_i\neq y_j	\\
  \end{array}\right.
  $$
  
+ **复杂度**：均为$O(n^2)$

## Lecture 7: Minimum Edit Distance Problem

### Minimum Edit Distance Problem（最小编辑距离）

+ Motivations and Applications

+ Problem Definition

  Given two strings X=(x1, x2,…, xm) and Y=(y1, y2,…, yn), the edit distance is the smallest number of following edit operations to turn X into Y:

  + Insertion: add a letter
  + Deletion: remove a letter
  + Substitution: replace a character with another one.

+ The Dynamic Programming Algorithm

  将$X[1...i]$转变为$Y[1...j]$分三种情况：

  + Case 1: Turn $X[1...i-1]$转变为$Y[1...j]$ 并删除 $X[i]$

    Example 1 : MED (cxy-> dab) =MED (cx-> dab) + 1

  + Case 2: Turn $X[1...i]$转变为$Y[1...j-1]$ 并插入 $Y[j]$

    Example 2: MED (cxy-> dab) = MED (cxy-> da) +1

  + Case 3: Turn $X[1...i-1]$转变为$Y[1...j-1]$  and 替换 $X[i]$ with $Y[j]$ if needed (X[i]+YUij)

    Example 3.1 : MED (cxy-> dab) =MED (cx-> da) +1

    Example 3.2: MED (cxy-> day) =MED (cx-> da)D[i-1,j+1D[i,j]=minD[i,j-1]+1D[i-1,j-1] +10 if X[i] =Yj](1 otherwise.

  则递推公式为：
  $$
  D[i.j]=min
  \begin{cases}
  D[i-1,j]+1 \\
  D[i,j-1]+1 \\
  D[i-1,j-1]+
  \begin{cases}
  0 & \text{if X[i]=Y[j]}\\
  1 & \text{otherwise}
  \end{cases}
  \end{cases}
  $$
  用一个辅助数组$p[i,j]$来存位置

  **复杂度**：$O(mn)$

## Lecture 9: Fraction Knapsack, Activity Selection and Huffman Coding Problems

### The Fractional Knapsack Problem（分数背包问题）

+ Problem Definition

+ A Greedy Algorithm and correctness

  先$O(n\log n)$按价值排序，之后$O(n)$按价值选物品，最后证明Correctness

### The Activity Selection Problem（活动选择问题）

#### Problem Definition

#### A Greedy Algorithm and correctness

* 贪心的选法：选择结束时间最早的活动

* 算法过程：先$O(n\log n)$按结束时间排序，之后最每次选结束时间最早的（当前第一个），去除冲突的活动。


##### 证明Correctness

基本思想：We can convert any other optimal solution(𝑃′) to the greedy algorithm solution(𝑃)

过程：

* Compare the activities in 𝑃′ and 𝑃 from left to right
* If they match in the selected activity  →  skip
* If they do not match, we can replace the activity in 𝑃′ by that in 𝑃 because the one in 𝑃 finish first

例如，在下图中，证明最优解可以“无损”转化为算法解，之前、之后的时间均不会影响

![image-20211105161531971](算法设计与分析 课程笔记.assets/image-20211105161531971.png)

#### Extended: Weighted Activity Selection

每一项活动加入权重$w_i$，找总权重和最大的活动序列

##### 算法思想

* 定义$p(j)$ 为最大的索引$i$使得活动$a_i$在第$j$个活动前且不冲突

* 动态规划递推关系：
  $$
  OPT(j)=
  \begin{cases}
  0, &\text{if j=0}	\\
  max\{ OPT(j-1), w_j + OPT(p(j)) \}, &\text{if j>0}	\\
  \end{cases}
  $$

* 一个例子

  ![image-20211105162615302](算法设计与分析 课程笔记.assets/image-20211105162615302.png)

### The Huffman Coding Problem（霍夫曼编码问题）

#### Problem Definition

* 一个检测后缀的算法可以检测是否满足唯一可译，1949年

#### A Greedy Algorithm

贪心思想：每次选最小的x，y组成子树，更新权重为x+y

#### 正确性证明



## Lecture 9.x 

补充了一部分关于香农的信息熵编码公式、Krash-McMilian公式及证明

### 信息熵

$$
H(X)=\sum_iP(x_i)I(x_i)=-\sum_iP(x_i)\log bP(x_i)
$$

在这里b是对数所使用的底，通常是2,自然常数e，或是10。当b = 2，熵的单位是bit；

### Kraft–McMillan公式

设符号表中的原始符号为
$$
S=\{ s_1,s_2,...,s_n \}
$$
在大小为$r$的字符集上编码为唯一可解编码的码字长度为
$$
l_1,l_2,...,l_n
$$
则
$$
\sum_{i=1}^n r^{-l_i} \leq 1
$$
反之，给定一个满足上述不等式的自然数集合$l_1,l_2,...,l_n$ , 则在大小为$r$字符集上，存在一组唯一可解编码符合相应的码字长度。

## Lecture 10: Review of BFS/DFS, Topological Sort and Strongly Connected Components  

### 关于图的概念

#### BFS

#### DFS

### 拓扑排序

Topological Sort

#### Topological Sort Algorithm 算法

拓朴排序：每个入度0加进去，删除

#### Topological Sort Algorithm 复杂度分析

* 复杂度$O(V+E)$

按DFS完成时间的倒序排列

考虑两顶点u -> v

* 若v灰色，则v为u祖先，形成环图，矛盾！
* 若v白色，正常输出
* 若v黑色

### 强连通分量

#### 概念

设$G= (V, E)$是一个有向图。

G的一个强连通分量(SCC)是G的一个子集的V使得：

对任意两个顶点$u,v\in S$，既有一条u-v的路径，也有一条v-u的路径。

S是一个最大集，不能在不违背上述条件的情况下向其中加入更多的结点V到S中

#### 求解SCC的算法

用到一个反转图G^R的思想

【摘自wiki】

1. 对有向图G取逆，得到G的反向图$G^R$
2. 利用深度优先搜索求出$G^R$的逆后排序
3. 对G按照上述逆后排序的序列进行深度优先搜索
4. 同一个深度优先搜索递归子程序中访问的所有顶点都在同一个强连通分量内

#### 算法过程 Finding SCCs

Step 1: Obtain the reverse graph GR by reversing the directions of all the edges in G.
Step 2: Perform DFS on GR, and obtain the sequence LR that the vertices in GR turn black (i.e., whenever a vertex is popped out of the stack, append it to LR). Obtain L as the reverse order of LR.
Step 3: Perform DFS on the original graph G by obeying the following rules:
Rule 1: Start the DFS at the first vertex of L.
Rule 2: Whenever a restart is needed, start from the first vertex of L that is still white.
Output the vertices in each DFS-tree as an SCC.

#### 复杂度分析

Steps 1 and 2 obviously require only 𝑂(|𝑉|+|𝐸|) time.

Regarding Step 3, the DFS itself takes 𝑂(|𝑉|+|𝐸|) time, but we still need to discuss the time to implement Rule 2. Namely, whenever DFS needs a restart, how do we find the first white vertex in L efficiently? This will be left as an exercise.

Hence, the overall execution time is $O(|V|+|E|)$. 

#### 正确性证明

也就是说，第一轮对于GR的DFS中，S2中最后一个顶点结束时间一定会晚于S1的最后一个顶点结束时间，这样在LR中S2的最后一个顶点比S1的更靠后，在L中更靠前。

## Lecture 11: Minimum Spanning Trees

Review to Part V

### 最小生成树

定义、概念等

### Prim’s algorithm

#### 核心思想

#### 算法内容

步骤0:选择任意元素r;设置S=fr和A=0。将r作为生成树的根

步骤1:找到一条最轻的边，使一条端点在S中，另一条端点在V\ s中将这条边添加到a中，将它的(其他)端点添加到S中。

步骤2如果V\S=0，则停止生成树输出(最小)a;否则，请执行步骤1。

#### 复杂度分析

简单回顾优先队列

使用优先队列PriQueue的情况下：

* 对每一个V需要$O(\log V)$的时间查询最小的；
* 对每一个E需要$O(\log V)$的时间在优先队列上Decrease-Key；

总复杂度为：
$$
O(V\log V+E\log V) = O((V+E)\log V)=O(E\log V)
$$

### Kruskal’s algorithm

The idea
The algorithm
The Disjoint Set Union-Find data structure
Analysis for Kruskal’s algorithm
