# 数据库系统原理

参考教材：《数据库系统概论》-第5版_完整版（王珊，萨师煊）

## 第一章 数据库系统概述/绪论

### 1.1 数据库系统概述

#### 基本概念

##### 信息

信息是指现实世界事物的存在方式或运动状态的反映。具体地说，信息是一种已经被加工为特定形式的数据，这种数据形式对接收者来说是有意义的，而且对当前和将来的决策具有明显的或实际的价值。在信息社会中，信息是一种资源，其重要性可以与物质和能量相提并论。信息是指现实世界事物的存在方式或运动状态的反映。具体地说，信息是一种已经被加工为特定形式的数据

##### 数据

数据的定义：**描述事物的符号记录。**

* 数据是将现实世界中的各种信息记录下的、可以识别的符号。

* 是信息的载体，信息的具体表示形式。
* 数据可用多种不同的形式来表示一种同样的信息，信息不随它的数据形式不同而改变。

##### 数据处理

定义：数据处理实际上就是利用计算机进行数据处理的过程

##### 数据库

定义：长期储存在计算机内的、有组织的、可共享的数据集合

##### 数据库管理系统（DBMS）

定义：一个通用的软件系统，由一组计算机程序构成。它能够对数据库进行有效的管理，并为用户提供了一个软件环境，方便用户使用数据库中的信息。

功能：

1. 数据定义功能
2. 数据组织、存储和管理
3. 数据操纵功能
4. 数据库的运行管理功能
5. 数据库的建立和维护功能
6. 其他功能

##### 数据库系统

定义：数据库系统是指一个计算机存储记录的系统。即，它是一个计算机系统，该系统的目标是存储信息并支持用户检索和更新所需要的信息。它通常由数据库，软件，硬件，用户几个部分组成。

#### 数据管理的三个阶段

数据管理技术的发展经历了==人工管理、文件系统、数据库系统==三个阶段。

##### 人工管理阶段

时间：50年代中期以前

特点：

* 数据不保存
* 应用程序管理数据
* 数据不共享
* 数据不具有独立性

##### 文件系统阶段

时间：50年代后期-60年代中期

特点：

* 数据以文件的形式长期保存。文件形式多样化（索引文件、链接文件、直接存取文件、倒排文件等）。
* 一个数据文件对应一个或几个用户程序，还是面向应用的，具有一定的共享性。
* 由文件系统管理数据。通过文件系统提供存取方法，支持对文件的基本操作（增、删、改、查等），用户程序不必考虑物理细节。数据的存取基本上以记录为单位。
* 数据与程序有一定的独立性，因为文件的逻辑结构与存储结构由系统进行转换，数据在存储上的改变不一定反映在程序上。

缺点：

* 完整性问题
* 原子性问题
* 并发访问异常
* 安全性问题

对应的具体问题：

* 数据冗余和不一致
* 数据访问困难
* 数据孤立
* 数据独立性差

{题目}文件系统阶段已经具有了一定的数据独立性（对）

##### 数据库系统阶段

时间：60年代后期开始

数据库观点：数据不是依赖于处理过程的附属品，而是现实世界中独立存在的对象。

特点：

* 面向全组织的结构化
* 数据集成与共享，可控冗余度
* 数据独立性好
* 统一的控制机制。

具体的四个控制机制：

* 数据的安全性控制（Security）

  保护数据以防止不合法的使用所造成的数据泄露和破坏。

  措施：用户标识与鉴定，存取控制。

* 数据的完整性控制（Integrity）

  数据的正确性、有效性、相容性。

  措施：完整性约束条件定义和检查。

* 并发控制（Concurrency）

  对多用户的并发操作加以控制、协调，防止其互相干扰而得到错误的结果并使数据库完整性遭到破坏。

  措施：封锁。

* 数据库恢复（Recovery）

  将数据库从错误状态恢复到某一已知的正确状态，防止数据丢失和损害，保证数据的正确性。

{题目}数据库系统与文件系统本质区别：数据库系统实现整体数据的结构化，文件系统终数据之间是孤立的

### 1.2 数据模型

#### 定义

模型是现实世界特征的模拟和抽象。数据模型则是**现实世界数据特征的抽象**。

{题目}数据模型的概念：数据模型是数据库中用来对现实世界进行抽象的工具，是数据库中用于提供信息表示和操作手段的形式构架

#### 分类

概念数据模型：按用户的观点来对数据和信息建模。

逻辑数据模型：从计算机实现的观点来对数据建模。

物理数据模型：从计算机的物理存储角度对数据建模。

#### 数据模型的组成要素

数据模型通常由==数据结构、数据操作和数据的完整性约束条件==三部分组成

##### 数据结构

定义：描述系统的静态特性，是所研究的对象类型的集合。包括：数据本身、数据之间的联系

##### 数据操作

描述施加于数据之上的各种操作，即对数据库中对象的实例允许执行的操作的集合，包括操作及操作规则，是对系统动态特性的描述。

一般有检索、更新（插入、删除、修改）操作。

##### 数据的（完整性）约束条件

是一组完整性规则的集合。完整性规则是给定的数据模型中数据及其联系所具有的制约和依存规则，用以限定符合数据模型的数据库状态及状态变化（所应满足的条件），以保证数据的正确、有效、相容。

#### 概念数据模型主要概念

##### 实体(Entity)

客观存在并可相互区分的事物叫实体。实体可以是具体的人、事、物，也可以是抽象的概念或联系。如一个学生、一次选课、老师与系的工作关系。

##### 属性(Attribute)

实体所具有的某一特性。一个实体可以由若干个属性来刻画。例如，学生实体可由学号、姓名、性别，出生年份、系、年级等组成。

##### 域(Domain)

属性的取值范围。

##### 实体型(Entity Type)

具有相同属性的实体必然具有共同的特征和性质，因此用实体名与其属性名集合来抽象和刻画同类实体，称为实体型。例，学生（学号、姓名、年龄、性别、系、年级）就是一个实体型。
注意实体型与实体（值）之间的区别，后者是前者的一个特例。如(9808100，王平，21，男，计算机系，2)是一个实体。

##### 实体集(Entity Set)

同型实体的集合称为实体集。如全体学生。

##### 码(Key)

能唯一标识实体的属性集称为码。如学号是学生实体的码。

##### 联系(Relationship)

定义：在现实世界中，事物内部以及事物之间存在着联系，这些联系在信息世界中反映为实体（型）内部的联系和实体（型）之间的联系。实体内部的联系通常是指组成实体的各属性之间的联系，实体之间的联系通常是指不同实体集之间的联系。

例子：如学生与老师间的授课关系，学生与学生间有班长关系。

种类：可以有一对一的（1:1），一对多的（1:m），多对多的（m:n）几种情况。

性质：

* 一般地，两个以上的实体型之间也存在着一对一、一对多、多对多联系。
* 同一个实体集内的各实体间也可以存在着一对一、一对多、多对多联系。

##### ER图绘制

* 矩形表示实体型
* 椭圆表示实体的属性
* 菱形表示实体间的联系
* 无向边把实体与其属性连接起来
* 参与联系的实体用线段连接
* 联系的数量写在横线上

#### 逻辑数据模型

常用的4类：==层次模型、网状模型、关系模型==、面向对象模型

##### 层次模型

定义：用树结构表示实体之间联系的模型

特性：

* 每棵树有且仅有一个结点无双亲结点，此结点称为树的根（Root）。
* 树中的其它结点都有且仅有一个双亲结点

![image-20220104102131256](数据库 笔记.assets/image-20220104102131256.png)

优点：

* 结构简单，易于实现。
* 较好的性能。
* 良好的完整性支持。

缺点：

* 难以描述现实世界中非层次性的联系。
* 子结点的存取只能通过双亲结点来进行。
* 层次命令趋向程序化。

##### 网状模型

定义：是一个满足下列条件的有向图：

1. 可以有一个以上的结点无双亲结点。
2. 至少有一个结点有多于一个的双亲结点。

![image-20220104102244910](数据库 笔记.assets/image-20220104102244910.png)

特点：

* 能够更为直接地描述现实世界。
* 具有良好的性能。

缺点：

* 结构复杂，不利最终用户掌握
* 其DDL，DML语言复杂，用户不易使用。

##### 关系模型

定义：用二维表来表示实体及其相互联系

优缺点：简单，表的概念直观，用户易理解。概念单一，实体和实体之间的联系都用关系表示。**存取路径对用户透明**，具有**更高的数据独立性**和更好的安全保密性。缺点是性能往往不如非关系数据模型。（有严格的数学概念基础、**数据结构简单**、**适用于集合操作**、有标准语言支持、无法表达表中套表等复杂数据结构）

### 1.3 数据库系统的结构

#### 模式的概念

##### 型与值

型（type）是指对某一类数据的结构和属性的说明，值（value）是型的一个具体赋值。

##### 模式与实例

定义：对数据库中全体数据的逻辑结构和特征的描述。

特点：

* 它仅仅涉及到型的描述，不涉及到具体的值。
* 模式的一个具体值称为模式的一个实例。同一个模式可以有很多实例。
* 模式是相对稳定的，而实例是相对变动的，因为数据库的数据是在不断更新的。
* 模式反映的是数据的结构及其联系，而实例反映的是数据库某一时刻的状态。

##### 模式的分级

为了提高数据的物理独立性和逻辑独立性，使数据库的用户观点，即用户看到的数据库，与数据库的物理方面，即实际存储的数据库区分开来，数据库系统的模式是分级的。

#### 三级模式结构

三级模式的概念：==外模式、模式、内模式==（概念模式、外模式、存储模式）

三级模式之间有两级映象。

##### 外模式(Sub-Schema)

也称子模式或用户模式。用户的数据视图。是数据的局部逻辑结构，==模式的子集==。

##### 模式(Schema)

也称逻辑模式。是所有用户的公共数据视图，是数据库中全体数据的全局逻辑结构和特性的描述。

##### 内模式(Storage Schema)

又称存储模式。数据的物理结构及存储方式，是数据在数据库内部的组织方式。一个数据库只有一个内模式

{题目}数据库系统的三级模式分别对应的是哪一种数据模型？

* 外模式和概念模式用的是逻辑模型，内模式用的是物理模型

#### 二级映像功能

##### 外模式/模式映象

定义某一个外模式和模式之间的对应关系，映象定义通常包含在各外模式中。==当模式改变时，修改此映象，使外模式保持不变，从而应用程序可以保持不变==，称为==**逻辑独立性**==。

##### 模式/内模式映象

定义数据逻辑结构与存储结构之间的对应关系。存储结构改变时，修改此映象，使模式保持不变，从而应用程序可以保持不变，称为==**物理独立性**==。

##### 性质

* 数据与程序之间的独立性，使得数据的定义和描述可以从应用程序中分离出去
* 由于数据的存取由数据库管理系统管理，从而简化了应用程序的编制，大大减少了应用程序的维护和修改

### 1.4 数据库系统的组成

数据库系统4大组成部分：数据库、软件、硬件、用户

#### 数据库管理员（DBA）

**5大职责：**

1. 决定数据库中的信息内容和结构
2. 决定数据库的存储结构和存取策略
3. 定义数据的安全性要求和完整性约束条件
4. 监控数据库的使用和运行
5. 数据库的改进和重组、重构

#### 数据库管理系统（DBMS）

==5大主要功能：数据库定义、数据存取、数据库运行管理、数据组织和存储、数据库建立和维护==

* 数据库定义功能：1、提供DDL语言（Data Description Language）描述外模式、模式和内模式。2、模式翻译程序把原模式翻译成目标模式，存入数据字典。
* 数据存取功能：提供DML（Data manipulation language）语言进行增删改查。
* 数据库运行管理：并发控制、存取控制、完整性约束条件检查和执行……
* 数据组织、存储和管理
* 数据库的建立和维护

#### 数据库技术的发展

第一代数据库系统：70年代的层次和网状数据库系统

第二代数据库系统：1970年IBM San Jose实验室研究员E.F.Codd提出关系模型

第三代数据库系统：面向对象数据库；数据库技术与其他学科的内容相互结合；面向应用领域的数据库技术研究

## 第二章 关系数据库

### 2.1 关系数据结构及形式化定义

#### 关系数据结构

关系模型是关系数据库系统的基础，它由以下部分组成：

* 数据结构：关系（二维表）。关系模型的数据结构非常单一，无论是实体还是实体间的联系均由关系表示。
* 完整性约束：包括关系模型所要求的完整性约束（实体完整性约束，参照完整性约束），以及应用领域需要遵循的用户定义完整性约束。
* 关系操作：包括：选择、投影、连接、除、并、交、差等查询操作和增加、删除、修改操作两大部分。其特点是集合操作方式，操作的对象及结果都是集合。
* 关系数据语言：
  * 关系代数：用对关系的运算来表达查询，需要指明所用操作。
  * 关系演算：用谓词来表达查询，只需描述所需信息的特性。
    * 元组关系演算：谓词变元的基本对象是元组变量。
    * 域关系演算：谓词变元的基本对象是域变量。
  * SQL语言

{作业} 关系模型的三个组成部分：1、关系数据结构；2、关系操作集合；3、关系完整性约束

#### 关系相关概念

##### 域

域（Domain）：一组具有相同的数据类型的值的集合

##### 关系模型的特点

* 列是同质的（Homogeneous）。即每一列中的分量来自同一域，是同一类型的数据。
* 不同的列可出自同一域，每列必须有不同的属性名。
* 列的顺序无关紧要，即列次序可以互换。
* 任意两个元组不能完全相同（集合内不能有相同的两个元素）。
* 行的顺序无关紧要，即行次序可以互换。
* 每一分量必须是不可再分的数据。满足这一条件的关系称作满足第一范式（1NF）的。

{作业} 关系模型是如何利用集合论来描述二维表的？答：关系模型通过笛卡尔积的子集来定义二维表。

##### 关系模式

关系的描述称作**关系模式**，它可以形式化地表示为：
$$
R(U,D,dom,F,I)
$$

* R为关系名
* U为组成该关系的属性名集合
* D为U中属性所来自的域
* DOM为属性向域的映像集合
* F为属性间数据的依赖关系集合

##### 关系数据库

在一个给定的应用领域中，所有实体及实体之间的联系的关系的集合构成一个关系数据库。关系数据库也有型和值之分：

* 其型是关系模式的集合，即数据库描述，称为关系数据库模式。
* 其值是这些关系模式在某一时刻对应的关系实例的集合，通常称为关系数据库实例。

#### 码与属性

##### 候选码

语言表述：

{作业} 在关系模式R（U）中，能唯一标识关系中元组的属性或属性集，称为候选码，也称候选关键字或候选键。候选码满足唯一性和最小性。

形式表述：

关系模式R（U）的属性集合$k\subseteq U$是候选码，如果
（1） R（U）的任何一个关系实例的任意两个元组在属性集合k上的值都不同。即**唯一性**，候选码的属性值必须能够唯一地标识关系中的所有元组。
（2） k的任何真子集都不满足条件（1）。即**最小性**，候选码不能包含多余属性。

##### 主码

若一个关系具有多个候选码时，选择其中一个作为该关系的主码。

##### 主属性与非主属性

候选码中的诸属性称为主属性，不包含在任何候选码中的属性称为非主属性。

* 在最简单的情况下，候选码只包括一个属性。
* 在最极端的情况下，关系模式的所有属性是这个关系模式的候选码，称为**全码**。

##### 外部码

* 设F是基本关系R的一个或一组属性，但不是R的码。如果F与基本关系S的主码Ks相对应，则称F是关系R的外部码（Foreign Key），并称R为参照关系（Referencing Relation），S为被参照关系（Referenced Relation）或目标关系（Target Relation）。R和S不一定是不同的关系。
* 显然，目标关系S的主码Ks和参照关系的外部码F必须定义在一个域上。

### 2.2 关系操作

#### 基本的关系操作

5种基本操作：集合并、集合差、广义笛卡儿积（乘）、选择、投影

#### 关系数据语言的分类

分为3类：关系代数、关系演算（元组xx、域xx）、具有xy双重特点的语言

### 2.3 关系的完整性

#### 完整性约束

关系模型必须满足的语义约束包括：==实体完整性、参照完整性==

##### 实体完整性

定义：关系R主码中所包含的任意属性都不能取空值

##### 参照完整性

如果关系R2的外部码Fk与关系R1的主码Pk相对应，则R2中的每一个元组的Fk值或者等于R1 中某个元组的Pk 值，或者为空值。

##### 用户定义的完整性

用户针对具体的应用环境定义的完整性约束条件。
如Sno要求是8位字符，Ssex要求取值为“男”或“女”。

##### 系统支持

略。实体完整性和参照完整性由系统自动支持。

### 2.4 关系代数

#### 分类

传统+专门运算=9种

* 传统的集合运算

  集合并、集合交、集合差、广义笛卡儿积

* 专门的关系运算
  选择、投影、连接、自然连接、商

* 基本运算（{题目}从数据库的角度看，核心的关系代数运算）
  ==集合并、集合差、广义笛卡儿积（乘）、选择、投影==

#### 传统集合运算

是二目运算，除了笛卡尔积外，要求参加运算的两个关系必须是同类关系。

* 并：由属于R或属于S的元组构成。记作：
  $$
  R\cup S=\{t|t\in R \or t\in S\}
  $$

* 差：由属于R而不属于S的元组构成。
  $$
  R-S=\{t|t\in R \and t\notin S\}
  $$

* 交：由既属于R又属于S的元组构成。
  $$
  R\cap S=\{t|t\in R \and t\in S\}
  $$

* 广义笛卡尔积：元组的前n个分量是R中的一个元组，后m个分量是S中的一个元组
  $$
  R\times S = \{t|t=<r,s> \and r\in R \and s\in S\}
  $$

#### 专门的关系运算

* 选择：在R中选择出满足给定条件的元组，记作：
  $$
  \sigma_F(R) = \{t|t∈R \and F(t)=true\}
  $$

* 投影：从关系R中取若干属性列组成新的关系，投影的结果中删除重复的行，记作：
  $$
  \pi_A(R)=\{t[A]|t∈R,A\sube R\}
  $$

* 连接：R和S在属性X和Y上的连接（X，Y是连接属性，即X和Y包含同等数量的属性，且相应属性有共同的域），是从两个关系的广义笛卡尔积里选出满足比较条件θ的元组，记作：
  $$
  \mathop{R\bowtie S}_{A \ \theta \ B}=\{t|t=<r,s>\and s∈S\and r∈R\and r[A]\ \theta \ s[B]\}
  $$

* 自然连接：在相同属性列取值相等为条件的连接，要去掉重复属性列。

* 除法：关系S的属性是关系R属性的子集，记为：
  $$
  R\div S=\{t|t∈\pi_X(R)\and s∈S\and <t,s>∈R\}
  $$
  （结果包含S中没有的属性）

#### 其它

##### 复合连接

类似于自然连接，是连接运算结果不包含连接属性的自然连接。

##### 半连接

在R与S的连接运算结果中只保留R的属性列所得到的元组集合。

##### 外连接

为避免自然连接时因失配而发生的信息丢失，可以假定往参与连接的一方表中附加一个取值全为空值的行，它和参与连接的另一方表中的任何一个未匹配上的元组都能匹配，称之为外连接。
外连接 = 自然连接 + 失配的元组。

#### 一些关系代数示例

* 查询年龄小于20岁的学生
  $$
  \sigma_{Age<20} (STUDENT)
  $$

* 查询学生的姓名和所在系
  $$
  \pi_{Sname, Sdept}(STUDENT)
  $$

* 查找学号为95001的学生姓名和年龄
  $$
  \pi_{Sname, Sage}(\sigma_{Sno='95001'} (STUDENT))
  $$

* 查询选修了全部课程的学生号和姓名
  $$
  \pi_{Sno，Cno}(SC)\div \pi_{Cno} (Course)\bowtie \pi_{Sno, sname}(STUDENT)
  $$

。。。其余例子见ppt、第二章作业

### 2.5 关系演算

#### 元组关系演算

基本结构是元组演算表达式。

##### 例子

* 查询信息系（IS）的全体学生
  $$
  \{t | STUDENT(t)\and t[5]='IS'\}
  $$

* 查询年龄小于20岁的学生
  $$
  \{t | STUDENT(t) \and t[3]<20\}
  $$

* 查询学生的姓名和所在的系
  $$
  \{t^{(2)} | (\exist u)(STUDENT(u)\and t[1]= u[2] \and t[2]=u[5])\}
  $$

。。。其余例子见ppt、第二章作业

#### 域关系演算

类似于元组演算，公式中的变量对应元组各个分量的域变量。

似乎不考？

* 查找学号为95001的学生姓名和年龄
  $$
  \{t_1t_2| (\exist u_1)(\exist u_3)(\exist u_5)(Student(u_1t_1u_3t_2u_5) \and u_1='95001')\}
  $$

#### 关系演算的安全性

含义：关系演算有可能会产生无限关系或导致无穷验证，这样的表达式是不安全的。

解决方法：需对两种关系演算进行限制，使之具有安全性。

## 第三章 SQL语言

### 3.1 SQL概述

#### SQL的特点

**5大特点：**综合统一、高度非过程化、面向集合的操作方式、以同一种语法结构提供多种使用方式、语言简捷，易学易用

具体阐述：

* 综合统一
  集数据定义，数据操纵，数据查询和数据控制于一体。
  单一的结构----关系，带来了数据操作符的统一。
* 高度非过程化
  用户只需提出“做什么”，无须告诉“怎么做”，不必了解存取路径。
* 面向集合的操作方式
  操作的对象和操作的结果均为集合。
* 以同一种语法结构提供多种使用方式
  SQL既是自含式语言，又是嵌入式语言
* 语言简捷，易学易用
  类似于英语自然语言

#### 基本概念

* 基本表
  是本身独立存在的表，一个（或多个）基本表对应一个存储文件
* 存储文件
  由数据块构成的存储空间，用于存储基本表、索引等。其逻辑结构组成了关系数据库的内模式
* 视图
  是从一个或几个基本表中导出的表，其本身不独立存储于数据库中

### 3.4 SQL数据查询功能

#### 单表查询

ppt（p13-23）

基本SELECT查询

* SELECT A FROM B：对应不去重的投影操作。
* SELECT DISTINCT A FROM B：对应投影。
* SELECT A FROM B WHERE C = D：选取检索，可以用AND、OR或NOT连接条件=，<>，>，>=，<，<=。可以使用BETWEEN a AND b表示某个区间。
* SELECT A FROM B WHERE C = D ORDER BY A ASC：对A升序排列，如果降序可以写DESC。
* WHERE后可以指明连接条件，选择需要的若干列。

聚集函数

* Count() 求元组个数
* Sum() 对数值列求总和
* Avg() 求数值列的平均值
* Max() 求最大值
* Min() 求最小值

#### 连接查询

ppt（p24-28）

连接条件：连接查询中用来连接两个表的条件称为连接条件或连接谓词

#### 嵌套查询

ppt（-p36例子）

#### 集合查询

insert、delete、update语句

例：第3章sql作业

```sql
--Exercise 3
Insert Into Student(Sno, Sname, Ssex, Sage, Syear, Shome, Smobile, Smnt)
  Values('26', '李四', '女', '20', '2008', '广东', '10010001000', '0110');
```

```sql
--Exercise 4
delete from Student where Sname = '李四'
```

```sql
--Exercise 11
update Student
  set Sage = 30
  where Sdept = '06'
```

### 3.3 SQL数据定义功能

定义语句，包括（创建+删除+修改）：模式Schema、表Table、视图View、索引Index

#### 定义、删除、修改基本表

* 定义 Create Table 
* 修改 Alter Table + （具体操作）
* 删除 Drop Table 

#### SQL92的数据类型

* char（n）：固定长度的字符串。
* varchar（n）：可变长字符串。
* int：整数。
* Real, double precision ：浮点数与双精度浮点数,精度与机器有关。
* Float(n)：n位的精度浮点数。
* date：日期（年、月、日）。
* time：时间（小时、分、秒）。

#### 完整性约束

* NULL/NOT NULL
* UNIQUE
* PRIMARY KEY
* FOREIGN KEY
* CHECK

以第3章sql作业为例，创建Student表：

```sql
Create table Student
(Sno char(4) not null,
Sname nvarchar(10) not null unique,
Ssex nchar(2) check(Ssex='男' or Ssex='女'),
Sage Int check (Sage>=10 and Sage<=50),
Syear char(2),
Shome nvarchar(10),
Sdept char(4),
Smnt char(4),
--Smobile char(15) unique,
Primary key(Sno),
Foreign key (Sdept) references Department(Dno),
Foreign key (Smnt) references Student(Sno));
```

#### 定义视图

##### 视图的概念

视图是由一个或几个基本表（或视图）导出的表，数据库不存储视图所对应的 数据，而仅在 数据字典中存储其定义，因此，也称视图为虚表。视图一经定义，就可以像基本表一样被查询和删除。

##### 视图的作用

* 能够简化用户操作
* 使用户能够以多种角度看待同一数据
* 对重构数据提供了一定程度的逻辑独立性
* 能够对机密数据提供安全保护

##### SQL视图操作

* 创建视图：Create View 
* 删除视图：Drop View 

第3章作业-第9题

创建一个视图，计算每门课的最高分。

```sql
create view Cno_MaxG(Cno, Gmax)
as select Cno, max(Grade) from SC
   group by Cno;
```

##### 视图消解（View Resolution）

DBMS执行对视图的查询时，从数据字典中取出视图的定义，把定义中的子查询和用户的查询结合起来，转换成等价的对基本表的查询，然后再执行修正的查询。这一转换过程称为视图消解。

### 3.5 SQL数据更新

### 3.? 嵌入式SQL

* 许多事务处理都是过程性的，需要根据不同的条件执行不同的任务，单纯使用SQL语言较难实现。
* 实际的应用系统是非常复杂的，数据库访问只是其中一个部件。有些动作如与用户交互、图形化显示数据等只能用高级语言实现。

* 嵌入式SQL分为：预编译方式和函数方式。

此部分没怎么讲

### 相关题目

#### SQL查询

2010年

1. 不稀奇
2. where xx in（）嵌套查询
3. 创建视图create view xxx as select + group by的按某一条件分组筛选
4. distinct去除重复结果 + 双重not exists否定检索全部...
5. 含有'%彩电%'的关键词模糊查找
6. 创建插入新数据：insert into W（属性1，2，3） values（xx，xx，xx）
7. 【另一题】创建表，create Table xx（包含属性类型、check（）、primary key、外键foreign key xx + 属性类型 + reference 课程（课程编号））

2011年

1. 双重select以及in（）筛选出既选修A课程、又选修B课程的学生
2. 双重not exist筛选出每个...都操作的...
3. 计算平均的Avg（）函数 + group by分组筛选
4. 介于一定范围内 between（20，40） + 姓王'王%'
5. 创建视图
6. 年龄+3等于Mary，嵌套
7. 插入数据
8. 【另一题】创建表create Table xx（日期类型date、not null、unique、primary key（）、外键foreign key（））

2012年

1. 创建表。双属性主键的写法：create table（..., primary key（BNO，CNO））；
2. 正常
3. 既...又...的嵌套查询
4. group by+属性，貌似需要一大堆
5. 创建视图
6. 双重not exist筛选 + 使用试图

#### 作业题

【第三章—第2题】创建一个数据库，需要创建几个文件，它们分别是做什么用的？它们对应于三级模式中的哪一级？创建的表存储在什么地方？它们对应于三级模式中的哪一级？

* 需要创建一个数据文件，用于存储数据库中的数据。同时，还会创建一个日志文件，用于数据库的故障恢复。
* 数据文件对应于三级模式中的内模式。
* 创建的表存储在数据文件里，它们对应于三级模式中的模式。

【第三章—第5题】子查询分为哪几种？它们之间有什么区别？

* 分为两类：不相关子查询和相关子查询。
* **不相关子查询**：不相关子查询的执行顺序是由内向外，即每个子查询在上一级查询处理前求解，子查询的结果集合作为其外部查询的检索条件的条件值。
* **相关子查询**：相关子查询的查询条件引用了其外部查询的某个属性值，从而其执行依赖于其外部查询。其执行顺序是：首先取外部查询选取一行记录(称为候选行)，然后子查询利用候选行中相关列的值查询结果数据。接着外部查询利用子查询返回的结果集合判断候选行是否满足检索条件，若满足，则把它放入外部查询的结果集合。重复上述步骤直到处理完外部查询的每一行候选行。

【第6题】索引的作用与缺点（答案来源存疑）

作用：

1. 保证每一行数据的唯一性
2. 加快数据检索速度
3. 加速表与表之间的连接
4. 用分组、排序子句检索时，减少查询中分组和排序时间
5. 提高系统性能

缺点：

1. 创建、维护索引耗费时间
2. 占用物理空间
3. 增、删、改数据时，也要动态维护索)引

【第7题<ii>】视图的优点（p126）

1. 能够简化用户操作
2. 使用户以多种角度看待同一数据
3. 对重构数据库提供了一定程度的逻辑独立性
4. 对机密数据提供安全保护

## 第四章 数据库的安全性

### 4.1 数据库安全性概述

计算机系统的安全性

计算机系统安全问题的分类：技术安全类、管理安全类、政策法律类

数据库的安全威胁的分类：1. 偶然地、无意地接触或修改DBMS管理下的数据；2. 蓄意的侵犯和敌意的攻击

**数据库的安全性：是指保护数据库以防止不合法的使用所造成的数据泄漏、更改和破坏。**它包括两个方面的含义：

* 向授权用户提供可靠的信息服务。
* 同时，拒绝非授权的对数据的存取访问请求，保证数据库管理下的数据的可用性、完整性和一致性，进而保护数据库所有者和使用者的合法权益。

### 4.2 数据库安全性控制

#### 常用方法与技术

安全技术主要包括：**用户标识与鉴别、多层存取控制、审计、视图和数据加密**

#### 用户标识与鉴别

用户标识和鉴别是系统提供的最外层安全保护措施。标识是指系统采用一定的方式标识其用户或应用程序的名字或身份。鉴别是指系统在用户或应用程序登录时判断其是否为合法的授权用户。通常的做法是采用用户名和口令。

#### 存取控制

定义：存取控制确保合法用户按照指定的权限使用DBMS和访问数据，而非法用户或不具有相关权限的用户则不能。

##### 存取控制机制

存取控制机制主要包括两个部分：

* **定义用户权限**，并将用户权限记录到数据字典中，形成安全规则或授权规则。其中，用户权限是指不同的用户对于不同的数据对象允许执行的操作权限。
* **合法权限检查**，每当用户发出数据库操作请求后，DBMS根据数据字典中的安全规则进行合法权限检查，决定是否接受用户的操作请求。
* 用户权限定义和合法权限检查机制一起组成了DBMS的安全子系统。

##### 存取控制分类

数据库的存取控制可以分为：

* ==**自主存取控制**== (discretionary access control，简称DAC)。用户对于不同的数据对象拥有不同的存取权限，不同的用户对同一对象也有不同的权限，而且用户还可以将其拥有的权限转授给其他用户。
* ==**强制存取控制**== (mandatory access control，简称MAC)。每一个数据对象被标以一定的密级，每一个用户也被授予某一个级别的许可证。对于任一个对象，只有具有合法许可证的用户才可以存取。

##### 强制存取方法

* 主体：是系统中的活动实体，既包括DBMS所管理的实际用户，也包括代表用户的各进程。
* 客体：是系统中的被动实体，是受主体操纵的，包括文件、基本表、索引、视图等
* 当某一主体以某一许可证级别注册入系统时，系统要求他对任何客体的存取必须遵循如下规则：
  * 仅当主体的许可证级别大于或等于客体的密级时，该主体才能读取相应的客体；
  * 仅当主体的许可证级别等于客体的密级时，该主体才能写相应的客体；

#### 角色与用户组

为了管理数据库特权的方便，数据库还支持角色和用户组的概念。

* **角色**是一组权限的集合，可以把它授予用户或其他角色。当把某个角色授予用户（或角色）或从用户（或角色）处收回时，就同时授予或收回了该角色代表的全部权限。
* **用户组**是一组具有相同特性用户的集合。在授权或收回权限时，可以以用户组为单位进行。

#### SQL语言权限操作

##### 授予权限

每一个用户都拥有自己定义的数据库对象如（基本表、视图等），除了他自己和拥有DBA权限的用户以外，其他用户都不能访问这些数据库对象。如果想和其他用户共享其中一部分数据库对象，就必须将这些数据库对象上的部分或全部权限授予其他用户。其语法格式为：

* 为用户授予用户级权限
  Grant Create Session to SCOTT;
* 为用户授予角色
  Grant Connect to SCOTT;
* 将权限授予角色
  Grant Create table to Student_role;
* 将角色授予角色
  Grant Resource to Student_role;
* 将角色授予用户组
  Grant Student_role to PUBLIC;

##### 回收权限

* 当要取消一个用户或角色的权限时，可以使用REVOKE语句将其收回

* 收回权限时，若该用户已将权限授予其它用户，则也一并收回。

* 例：取消用户SCOTT的Create Table权限。

  ```sql
  Revoke Create Table From SCOTT;
  ```

### 4.3 视图机制

为不同的用户定义不同的视图，可以将用户对数据的访问限制在一定的范围内。

例：限制王平只能检索Student表中计算机系学生的学号和姓名。

```sql
Create View CS_Student
       As Select Sno, Sname From Student
       Where Sdept = ‘CS’;
Grant Select On CS_Student To Wangping;
```

### 4.4-4.5 审计和数据加密

* 审计功能把用户对数据库的所有操作都自动记录下来放入审计日志中。DBA可以利用审计跟踪的信息，重现导致数据库现有状况的一系列事件，找出非法存取数据的人、时间和内容等。
* 数据加密是防止数据库中数据在存储和传输中失密的有效手段。加密的基本思想是根据一定的算法将原始数据（明文）变换为不可识别的格式（密文），从而使得不知道解密算法的人无法获知数据的内容。

## 第五章 数据库的完整性

### 完整性基本概念

#### 定义

**数据库的完整性：指数据的==正确性和相容性==。**

* 正确性是指数据应具有合法的类型（符合现实世界语义、反映当前实际状况）。
  * 如数值型的字段只能含有0~9，不能包含其它符号；更进一步，数据还应在有效的取值范围之内，如一年最多只有12个月，不能出现13个月。
* 相容性是指表示同一个事实的两个数据应该相同（数据库同一对象在不同关系表中的数据时符合逻辑的）。
  * 如一个人不应当存在两个年龄。
* 数据库能否保持完整性关系到数据库系统是否能够真实的反映现实世界，因此维护数据库的完整性十分重要

#### 与安全性的比较

* 数据库的完整性与安全性是两个不同的概念。
* 前者是为了防止数据库中存在不符合语义的数据，防止错误信息的输入和输出，即所谓的垃圾进垃圾出所造成的无效操作和错误结果。
* 后者是保护数据库防止恶意的破坏和非法存取。
* 也就是说，安全性防范的是非法用户和非法操作，完整性措施的防范对象是不合语义的数据。

### 完整性约束条件

#### 定义

**数据库完整性约束条件**：施加在数据库数据之上的语义约束条件

#### 作用对象

完整性约束条件作用的对象可以是==关系、元组、列==三种

* 列约束主要是列的类型、取值范围、精度等约束条件。
* 元组的约束是元组中各个字段间联系的约束。
* 关系的约束是若干元组间、关系集合上以及关系之间的联系的约束

#### 种类细分

涉及这三类对象的完整性约束又可分为静态约束和动态约束

* 静态约束是指数据库<u>每一确定状态</u>（在某一时刻数据库中的所有数据实例构成了数据库的一个状态）时，数据对象所应满足的约束条件，它是反映数据库<u>状态合理性</u>的约束。
  * 固有约束
    指数据模型固有的约束，如关系的属性应当是原子的。
  * 隐含约束
    指隐含于数据模式的约束，一般用DDL语句说明，并存于数据字典中。如实体完整性约束。（建表的语句属于DDL，chech是在Create Table里，因此check属于隐含约束）
  * 显式约束
    指固有约束，隐含约束之外，依赖于数据的语义和应用，需要显式定义的完整性约束
* 动态约束是指数据库<u>从一种状态转变为另一种状态</u>时，新、旧值之间所应满足的约束条件，它是反映数据库<u>状态变迁</u>的约束

#### 静态约束

* 静态列级约束是对一个列的取值域的说明，包括：对数据类型的约束、对数据格式的约束、对取值范围或取值集合的约束、对空值的约束 、其他约束
* 静态元组约束规定了组成一个元组的各个列之间的约束关系。
  * 如：教师关系中有职称和工资属性，规定职称为’教授’的教师工资不得低于1000元
* 静态关系约束规定了一个关系的若干元组或者若干关系之间常常存在的各种联系或约束。包括：实体完整性约束、参照完整性约束、函数依赖、统计约束

#### 动态约束

* 动态列级约束是修改列定义或列值时应满足的约束条件，包括：
  * 修改列定义时的约束
    如不能在包含null的列上定义 not null约束。
  * 修改列值时的约束
    如工资只能增长，不能降低
* 动态元组约束指修改元组值时元组中各个字段间需要满足的约束。
  * 如规定调整后的工资不能低于原工资×（1+工龄/20）
* 动态关系约束是加在关系变化前后状态上的限制条件。
  * 如在工商银行和建设银行的账户A和B之间转账，要求New A + New B = Old A + Old B

### 数据库的完整性控制机制

#### 机制的三个功能

为保护数据库的完整性，防止错误的数据进入数据库，数据库提供了完整性控制机制。它包括三个方面的功能：==**提供定义完整性约束条件的机制、提供完整性检查的方法、具有违约响应**==

书的版本（p156）

1. 提供定义完整性约束条件的机制
2. 提供完整性检查的方法
3. 进行违约处理

PPT版本（第四章-p47）

* 定义功能，提供定义完整性约束条件的机制。
* 检查功能，检查用户发出的操作请求是否违背了完整性约束条件。
* 违约响应，若违背了完整性约束条件，则采取一定措施来保证数据的完整性。

#### 完整性检查的时机

* **立即执行约束**：指在执行用户事务的过程中，在一条语句执行完后立即进行完整性约束的检查。若违背了完整性约束，系统将拒绝该操作。
* **延迟执行约束**：指在整个用户事务执行完毕后，再进行完整性约束的检查，若正确方允许提交事务。若违背了完整性约束，系统将拒绝整个事务。

#### 完整性规则

一条完整性规则可以用一个五元组（D，O，A，C，P）来描述，其中：

* D（Data）约束所作用的数据对象
* O（Operation）触发完整性检查的数据库操作，即当用户发出什么操作请求时需要检查该完整性规则，是立即检查还是延迟检查。
* A（Assertion）数据对象必须满足的断言或语义约束。
* C（Condition）选择A作用的数据对象值的谓词。
* P（Procedure）违反完整性规则时触发的过程。

一个例子：教授的工资不得低于1000元。

* D 约束作用的对象为工资Sal属性
* O 插入或修改职工元组时
* A Sal不能小于1000
* C 职称=‘教授’
* P 拒绝执行该操作

#### 违约响应与检查时机

* 实体完整性和其他用DDL定义的约束：Insert 或者Update时检查。若违反，则拒绝相应操作

* 参照完整性：Insert、Update、Delete时检查

  | 被参照表           | 参照表             | 违约处理               |
  | ------------------ | ------------------ | ---------------------- |
  | 可能破坏参照完整性 | 插入元组           | 拒绝                   |
  | 可能破坏参照完整性 | 修改外码值         | 拒绝                   |
  | 删除元组           | 可能破坏参照完整性 | 拒绝/级联删除/设为空值 |
  | 修改主码值         | 可能破坏参照完整性 | 拒绝/级联更新/设为空值 |

#### 显式完整性约束的说明

三种表示说明方式：用<u>过程说明约束、用断言说明约束、用触发器表示约束</u>

* 用过程说明约束
  * 把约束的说明和检验作为一个过程，由程序员编码到每个更新数据库的事务中。用以检验数据库更新是否违反了给定约束。
* 用断言说明约束
  * 断言指数据库必须满足的逻辑条件，数据库完整性约束可以看成一系列断言的集合。
  * 使用这种方法DBMS需要提供断言说明语言，用以定义断言。并提供完整性验证子系统将其编译和存储到约束库，
  * 对于每个更新事务，完整性检查子系统利用约束库中的定义进行检查，判断是否违背了完整性约束。
* 用触发器表示约束
  * 触发器就是一类事件驱动的特殊过程，一旦定义，当发生预定义的事件时，系统自动执行相应的触发器。
  * 定义触发器时，需要定义：触发器的触发条件以及触发器应当完成的操作。
  * 注意：断言表示数据库状态应当满足的条件，而触发器中的条件却是违反约束的条件，二者正好相反。

## 第六章 关系数据理论

### 6.1 问题的提出

* 关系数据理论借助于数学工具规定了一套关系数据库设计的理论和方法。是数据库逻辑设计的有力工具。

* 关系数据库设计中存在的问题：插入异常、删除异常、数据冗余和更新异常
  * 原因：把多个实体型用一个关系模式表示
  * 解决之道：分解

### 6.2 规范化

#### 函数依赖

数据依赖是通过关系中属性间值的相等与否体现出来的数据间的相互关系，它是现实世界属性间相互联系的抽象，是数据内在的性质，是语义的体现。其中最重要的是函数依赖。

##### 定义

定义：设R(U)是属性集U上的关系模式，X , Y 是U的子集。若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不等，则称X函数决定Y，或Y函数依赖于X，记作 $X\rightarrow Y$。

* 简单来说，对于X的每个具体值，Y有唯一的值与之对应，则称X<u>函数确定</u>Y或Y<u>函数依赖</u>于X。

##### 特点

* 函数依赖是不随时间而变的。若关系模式R具有函数依赖 $X\rightarrow Y$ ，那么虽然关系模式R的关系实例r在X，Y上的取值各不相同，并且随时间而变化， 但X，Y在任一特定时刻都保持函数依赖 $X\rightarrow Y$ 。
* 函数依赖不是指关系模式R的某个或某些关系满足的约束条件，而是指R的一切关系均要满足的约束条件。
* 函数依赖是语义范畴的概念，它反映了一种语义完整性约束，只能根据语义来确定一个函数依赖。

##### 与属性间联系的关系

函数依赖与属性间的联系类型有关。

* 当X、Y之间是“1对1”联系时，则存在函数依赖 $X\rightarrow Y$ 和 $X\rightarrow Y$。
  * 如：学号和身份证号
* 当X、Y之间是“多对1”联系时，则存在函数依赖 $X\rightarrow Y$ 。
  * 如：SNO和DEPT
* 当X、Y之间是“多对多”联系时，则不存在函数依赖。
  * 如：SNO和CNO

##### 相关术语

* 平凡函数依赖：$Y\sube X$。如（SNO，SNAME）$\rightarrow$ SNAME是平凡的函数依赖

* 非平凡函数依赖：如果 $X\rightarrow Y$ ，但 $Y\nsubseteq X$ ，则称其为非平凡的函数依赖

* 决定因素：$X$是$X\rightarrow Y$的决定因素。

* 完全函数依赖：如果有$X\rightarrow Y$且对于任意$X$的真子集$X'$都有$X'\nrightarrow Y$，则是完全函数依赖。Y对X完全函数依赖，记作：
  $$
  X \mathop{\longrightarrow}^f Y
  $$

* 部分函数依赖：不是完全函数依赖的函数依赖。记作
  $$
  X \mathop{\longrightarrow}^p Y
  $$

* 传递函数依赖：$X\rightarrow Y$ 且$Y\rightarrow Z$，并且$Y \nrightarrow X$，则称$Z$对$X$传递函数依赖。

#### 码

##### 相关概念的形式定义

* 候选码：K为R< U , F >的属性或属性组，若U对K完全函数依赖，则称K为R的一个候选码。若候选码多于一个，则选定其中一个作为主码。
* 超码：设K为R< U , F >的属性或属性组，若 $K\rightarrow U$ ，则称K为R的超码。

* 主属性：包含在任何一个候选码中的属性。
* 非主属性：不包含在任何一个候选码中的属性，称作非主属性。
* 全码：关系模式的码由整个属性组构成。如（P，W，A）

#### 范式与规范化

范式：范式是对关系的不同数据依赖程度的要求。如果一个关系满足某个范式所指定的约束集，则称它属于某个特定的范式。

规范化：一个低一级范式的关系模式，通过**模式分解**可以转换为若干个高级范式的关系模式的集合，这一过程称作**规范化**。

##### 1NF

* 定义：关系中每一分量必须是原子的，不可再分。即不能以集合、序列等作为属性值。
* 当一个关系只包含原子值这一约束时，称为1NF。也就是表里每个格只有一个值。

##### 2NF

* 定义：1NF的关系的**每个非主属性完全依赖于码**，就是2NF。
* 转换方法：将1NF的关系模式规范化为2NF的关系模式，其方法是消除1NF的关系模式中非主属性对码的部分依赖。（如拆分为多个表）
* 不良特性：插入异常有所改善但是仍然存在、删除异常、数据冗余得到了一定的改善。

##### 3NF

关系模式R< U , F >中，若不存在这样的码$X$，属性组$Y$和非主属性 $Z(Z\nsubseteq Y)$ ，使得下式成立，
$$
X\rightarrow Y,\ Y\rightarrow Z,\ Y \nrightarrow X
$$
则称 $R∈3NF$ 。

* 将2NF的关系模式规范化为3NF的关系模式，其方法是消除2NF的关系模式中非主属性对码的**传递依赖**。

##### BCNF

若关系模式R< U , F >$\in$1NF，若 $X\rightarrow Y$ ，且 $Y\nsubseteq X$ 时，X必含有码，则R< U , F > $\in$BCNF。

性质：

* 所有非主属性都完全函数依赖于每个候选码。
* 所有主属性都完全函数依赖于每个不包含它的候选码。
* 没任何属性完全函数依赖于非码的任意一组属性。

简单来说，所有箭头左边一定是码

##### 多值依赖与4NF

非考点

### 6.3 数据依赖的公理系统

#### 逻辑蕴涵

对于满足一组函数依赖F的关系模式R< U, F >，其任何一个关系r，若函数依赖 $X \rightarrow Y$ 都成立，则称 $F$ 逻辑蕴涵 $X \rightarrow Y$ 。

F​的闭包：在关系模式R< U, F >中，为F所逻辑蕴涵的函数依赖的全体称作F的闭包，记作F+。例：
$$
F=\{X\rightarrow Y,\ Y\rightarrow Z\}，则\{X\rightarrow Z\} \subseteq F^+。
$$

#### Armstrong公理

对于$R<U, F>$有如下规则：

* A1自反律：若$Y\sube X\sube U$则$X \rightarrow Y$为$F$所蕴涵。
* A2增广律：若$X \rightarrow Y$为$F$所蕴涵，且$Z\sube U$则$XZ\rightarrow YZ$为$F$所蕴涵。
* A3传递律：若$X \rightarrow Y$且$Y \rightarrow Z$为$F$所蕴涵，则$X \rightarrow Z$为$F$所蕴涵。

##### 有效性与完备性

* 有效性：由F出发根据Armstrong公理推导出来的函数依赖一定在F+中。
* 完备性： F+中的每一个函数依赖都可以由F出发根据Armstrong公理从F中导出。

##### 属性集闭包

设F为属性集U上的一组函数依赖，$X\subseteq U$ ，
$$
X_F^+ = \{A | X\rightarrow A能由F根据Armstrong公理导出\}
$$
称 $X_F^+$ 为属性集X关于函数依赖集F的闭包。

求属性闭包的算法：

* 初始，$X_F^+=X$，然后把$F$中所有$X_F$下属性能推出的属性都加进去，直到不变或者变为属性全集$U$。

##### 推论

* 合并规则：由$X \rightarrow Y$，$Y \rightarrow Z$，有$X \rightarrow YZ$。
* 伪传递规则：由$X \rightarrow Y$，$WY \rightarrow Z$，有$XW \rightarrow Z$。
* 分解规则：由$X \rightarrow Y$和$Z \sube Y$，有$X \rightarrow Z$。
* 定理1：$X \rightarrow A_1 A_2 A_3\dots A_k$成立等价于$X\rightarrow A_i$（i = 1, 2, 3...k）成立。

### 候选码的求解

ppt中缺失此部分（摘自：https://blog.csdn.net/zhang1213885531/article/details/80961983）

#### 属性分类

对于给定的关系R（A1，A2，…An）和函数依赖集F，可将其属性分为4类：

* L类  仅出现在函数依赖左部的属性。
* R 类  仅出现在函数依赖右部的属性。
* N 类  在函数依赖左右两边均未出现的属性。
* LR类  在函数依赖左右两边均出现的属性。

#### 定理与推论

* 定理：对于给定的关系模式R及其函数依赖集F，若X（X∈R）是L类属性，则X必为R的任一候选码的成员。
* 推论：对于给定的关系模式R及其函数依赖集F，若X（X∈R）是L类属性，且X+包含了R的全部属性；则X必为R的唯一候选码。
* 定理：对于给定的关系模式R及其函数依赖集F，若X（X∈R）是R类属性，则X不在任何候选码中。
* 定理：对于给定的关系模式R及其函数依赖集F，若X（X∈R）是N类属性，则X必包含在R的任一候选码中。
* 推论：对于给定的关系模式R及其函数依赖集F，若X（X∈R）是L类和N类组成的属性集，且X+包含了R的全部属性；则X是R的唯一候选码。

#### 算法步骤

1. 将R 的所有属性分为L、R、LR 和N 四类，并令X 代表L、N 类，Y 代表LR 类。 
2. 求X+。若X+包含了R 的全部属性，则即为R 的唯一候选码，转（5）；否则，转（3）。
3. 在Y 中取一属性A，求（XA）+ ，若它包含了R 的全部属性，则是候选码，转（4）；否则，调换一属性反复进行这一过程，直到试完所有Y 中的属性。 
4. 如果已找出所有候选码，则转（5）；否则在Y 中依次取2 个、3 个、…（此时需要去除刚才选出的，否则不满足候选码完全依赖的“最小性”），求它们的属性闭包，若其闭包包含R 的全部属性，则是候选码。 
5. 结束

#### 求解候选码例题

【第六章作业-第4题】设有关系模式$R(ABCDE)$，其函数依赖集$F=\{A\rightarrow BC, CD\rightarrow E, B\rightarrow D, E\rightarrow A\}$

* 一种解法：A、B、C、D、E均在LR中，逐个尝试A-E，发现A与E可为候选码；

  对BCD两两组合尝试，发现$(B,C)$与$(C,D)$均可构成候选码，有依赖$B\rightarrow D$故不考虑$(B,D)$

* 候选码有4个：即$A,E,(B,C),(C,D)$

### 函数依赖集的最小覆盖

#### 函数依赖等价性

函数依赖集的等价性：函数依赖集F，G，若F+= G+，则称F与G等价
$$
F^+=G^+ \iff F\subseteq G^+, G\subseteq F^+
$$
最小依赖集（最小覆盖）：满足下列条件的函数依赖集F称为最小覆盖，记作$F_m$：

+ F中任一函数依赖的右部仅含有一个属性
+ 不存在传递函数依赖：F中不存在这样的函数依赖$X\rightarrow A$，使得F与$F-\{X\rightarrow A\}$等价。
+ 不存在部分函数依赖：F中不存在这样的函数依赖$X\rightarrow A$，在X中有真子集Z，使得F与$F-\{X\rightarrow A\} \cup \{ Z \rightarrow A \}$等价

#### 求解算法

算法：（求解函数依赖集F的最小覆盖$F_m$）

1. 【将F中的所有依赖右边化为单一元素】：若 $X\rightarrow Y$ 且 $Y=A_1A_2...A_k(k\geq 2)$ ，用诸 $X\rightarrow A_i$ 代替Y；
2. 【去掉F中所有冗余依赖关系】：逐个检查F中各函数依赖$X\rightarrow A$，令$G = F-\{X\rightarrow A\}$，若$A\in X_G^+$，则从F中去掉该函数依赖。
3. 【去掉F中的所有依赖左边的冗余属性】：逐个检查F中各函数依赖$X\rightarrow A$，设$X = B_1...B_m$，逐个考查$B_i$，若$A\in (X-B_i)_F^+$，则以$(X-B_i)$取代 $X$ 。（例如有A->C，可以删掉AD->C）

### 6.4 模式的分解

#### 分解目标

分解的目标：**无损连接分解、保持函数依赖、达到更高级范式**

* 无损连接：可以通过自然连接恢复到原来的关系；
* 保持函数依赖：同时也保持了原关系的函数依赖；
* 达到更高级范式：消除了原关系的异常。如分解三达到<BC范式>

#### 无损连接分解

##### 形式定义

一般定义： $\rho = \{R_1<U_1,F_1> , R_2<U_2 , F_2>, … , R_n<U_n , F_n>\}$ 是R<U , F>的一个分解，r是R<U , F>的一个关系。定义 $m_\rho(r) =\mathop{\bowtie}\limits_{i=1}^n \prod R_i(r)$  ,若对于R<U , F>的任一个关系r，都有 $r = m_\rho(r)$ ，则称 $\rho$ 是R<U , F>的一个无损连接分解。

* 简单来说就是拆分后，自然连接结果与原来的关系一样

#### 无损连接判别

##### 方法一：一个填表的方法

算法：（判别一个分解的无损连接性）

1. 填矩阵$a_i,b_{ij}$
2. 按所有依赖操作对应列，改变元素。如果在某次更改之后，有一行成为a1, a2 , … , an 。则算法终止， $\rho$为无损分解，否则为有损分解
3. 扫描后若无变化，终止；否则返回第二步

（举例p66-p73）

示例：$U=\{A,B,C,D,E\}, F={AB\rightarrow C, C\rightarrow D,D\rightarrow E},\rho ={(A, B, C), (C, D), (D, E)}$

##### 方法二：无损连接定理

定理：若$U_1 \cap U_2 \rightarrow U_1(or \ U_2)$。若满足，可判断是无损连接

填表法可证明定理（第二行为a1-a3）

|        | $U_1 \cap U_2$ | $U_1 - U_1 \cap U_2$ | $U_2 - U_1 \cap U_2$ |
| ------ | -------------- | -------------------- | -------------------- |
| R1(U1) | $a_1$          | $a_2$                | $b_{13}$             |
| R2(U2) |                | $a_2$                | $a_3$                |

#### 函数依赖分解

若
$$
F^+=(\ \mathop{\bigcup}\limits_{i=1}^n F_i\ )^+
$$
则称R< U , F >的分解 $\rho = \{R_1<U_1,F_1> , R_2<U_2 , F_2>, … , R_n<U_n , F_n>\}$ 保持函数依赖。

* 简单说就是包含了之前全部的函数依赖

#### 模式分解的算法

##### 3NF+函数依赖

【算法6.3】达到3NF且保持函数依赖的分解

1. 对$R<U,F> $中的函数依赖集F进行“极小化处理”（处理后得到的依赖集仍记为F）。
2. 找出不在F中出现的属性，将它们构成一个关系模式，并从U中去掉它们(剩余属性仍记为U)。
3. 若有$X\rightarrow A \in F$，且$XA=U$，则$\rho =\{R\}$，算法终止。
4. 否则，对F按具有相同左部的原则进行分组（设为k组），每一组函数依赖Fi‘所涉及的全部属性为Ui。若 $U_i \subseteq U_j (i\neq j)$  ，就去掉Ui 。由于经过了步骤2，故 $U = \mathop{\bigcup}\limits_{i=1}^n U_i$，于是 $\rho = \{R_1<U_1,F_1> , R_2<U_2 , F_2>, … , R_n<U_n , F_n>\}$ 是R<U , F>的一个保持函数依赖的分解，并且每个 $R_i<U_i,F_i>\in 3NF$ 。

* 简单说，每个函数依赖涉及到的属性分为一类U，包含全部涉及的F（去掉包含关系中小的）

例子p78

##### 3NF+函数依赖+无损分解

【算法6.4】达到3NF且同时保持无损连接与函数依赖的分解

设X为R<U , F>的码，设 $\rho = \{R_1<U_1,F_1> , R_2<U_2 , F_2>, … , R_n<U_n , F_n>\}$ 是R<U , F>的一个保持函数依赖的3NF分解。令 $\tau= \rho \cup \{R^*<X,F_X>\}$

若有某个Ui，$X\subseteq U_i$ ，则将 $R^*<X,F_X>$ 从 $\tau$ 去掉。

$\tau= \rho \cup \{R^*<X,F_X>\}$ 即为所求的解。

* 简单说，在3NF+函数依赖分解基础上，视情况加上键（码）到分解中

例子p81

##### BCNF+无损分解

【算法6.5】达到BCNF无损连接分解算法

给定关系模式R<U , F> ，

1. 令 $\rho = \{R<U , F>\}$
2. 检查 $\rho$ 中各关系模式是否属于BCNF，若是，则算法终止。 
3. 设 $\rho$ 中Ri<Ui , Fi>不属于BCNF，
   	则存在函数依赖 $X\rightarrow A \in F_i^+$ ，且X不是Ri的码，
   	则XA是Ri的真子集，将Ri分解为 $\sigma = \{S_1,S_2\}$，
   	其中 $U_{S_1}=XA$，$U_{S_2}=U_i-\{A\}$
   	以 $\sigma$ 代替Ri ，返回到2.

例子见p83

## 第七章 数据库设计

### 7.1 数据库设计概述

#### 设计的定义

数据库设计是指对于一个给定的应用领域，构造最优的数据库模式，建立数据库及其应用系统，使之能够有效地存储数据，满足各种用户的应用需求（信息要求和处理要求）数据操作需求，有效地支持各种应用系统的开发和运行。

#### 设计特点

1. **三分技术，七分管理，十二分基础数据**
2. 数据库设计与硬件、软件等紧密相关
3. **数据库设计要把结构（数据）设计和行为（处理）设计密切结合起来。**

{作业} 设计特点答的是分布进行、反复性、试探性3点

#### 设计方法

三种设计方法：手工试凑方法、规范化设计方法、自动数据库设计工具

##### 规范化设计方法

依据软件工程的思想，把整个设计过程划分为若干阶段，把数据库设计这一复杂的大问题分为若干相对简单的小问题，每个阶段只解决整个设计中的部分问题。

三个特点：

* **分步进行**
  数据库设计常常由不同的人员分阶段进行。一是由于技术上分工的需要，二是为了分段把关，逐级审查，保证设计的质量和进度。
* **反复性**
  数据库设计需要反复推敲和修改才能完成。前阶段的设计是后阶段设计的基础和起点，但后阶段也可向前阶段反馈其要求，反复修改，以臻完善。
* **试探性**
  数据库设计结果一般不是唯一的。设计的过程是个试探的过程。在设计过程中，有各式各样的要求和制约因素，何去何从取决于数据库设计者的权衡和决策。

#### 设计的基本步骤

分为6个阶段

1. **需求分析**：调查情况、熟悉业务、预测
2. **概念结构设计**
3. **逻辑结构设计**
4. **物理结构设计**
5. **数据库的实施**
6. **数据库运行与维护**

### 7.2 需求分析

#### 需求分析的任务

通过详细调查现实世界要处理的对象（组织、部门、企业等），充分了解原系统（手工系统或计算机系统）的工作情况，明确用户的各种需求，并预测系统今后可能的扩充和改变，然后在此基础上确定新系统的功能。

调查的重点是“数据”和“处理”，包括：

* 信息要求，指用户需要从数据库中获得的信息的内容与性质。从中可以导出数据要求。
* 处理要求，指用户要完成什么处理功能，对处理的响应时间和处理方式的要求。
* 安全性与完整性的要求

#### 需求分析的方法

具体步骤：

* 调查组织机构情况
* 调查各部门的业务活动情况
* 在熟悉了业务活动的基础上，协助用户明确对新系统的各种要求，包括信息要求、处理要求、完整性与安全性要求。
* 确定新系统的边界
* 预测系统的未来改变
* 强调用户参与

#### 数据字典

数据字典是系统中各类数据描述的集合，是进行详细的数据收集和数据分析所获得的主要成果

数据字典包括5方面：数据项、数据结构、数据流、数据存储、处理过程

### 7.3 概念结构设计

定义：将需求分析得到的用户需求抽象成为信息结构即概念模型的过程

#### 概念结构的特点

1. 能真实、充分地反映现实世界，包括事物和事物之间地联系，能满足用户对数据的处理要求。
2. 易于理解，从而可以用它和不熟悉计算机的用户交换意见。
3. 易于更改，当应用环境和应用要求发生改变时，容易对其进行修改和扩充。
4. 易于向关系、网状、层次等各种数据模型转换

#### 信息与应用定义

根据需求分析的结果，对应用领域进行分析，抽象出下列信息：应用领域的流动信息的定义、应用领域的存储信息的定义、应用领域中各种流动信息的起点和源点、应用领域的各种应用的定义（包括输入信息，输出信息和应用功能的定义）、上述四者之间的联系的定义。

* 应用定义的目的是确定最终数据库支持哪些应用系统。应用领域的逻辑模型是应用定义的基础
* 信息定义的目的是确定最终数据库需要存储哪些信息。信息的定义也以应用领域的逻辑模型为基础。

#### 概念结构的设计策略

* 自顶向下：首先定义全局概念结构的框架，然后逐步细化
* 自底向上：首先定义各局部应用的概念结构，然后将它们集成起来，得到全局概念结构。
* 逐步扩张：首先定义最重要的核心概念结构，然后向外扩充，以滚雪球的方式逐步生成其他概念结构，直至总体概念结构
* 混合策略：即将自顶向下和自底向上相结合

#### ER图

##### 局部视图设计

* 确定局部实体
* 确定局部实体之间的联系（包括超类/子类联系）
* 构造局部ER图

局部视图设计的关键在于实体和属性的正确划分。其主要手段为：分类、聚集、概况

##### 实体与属性

实体与属性划分的两条准则：

* 作为属性，不能再具有需要描述的性质。属性必须是不可分的数据项，不能包含其他属性。
* 属性不能与其他实体具有联系，即ER图中所表示的联系是实体之间的联系。

##### 视图的集成

视图的集成可以有两种方法：

* 多个局部ER图一次集成
* 逐步集成，用累加的方式一次集成两个分ER图。

集成步骤：

* 合并
  解决各局部ER图之间的冲突，将各局部ER图合并起来生成初步ER图。
* 修改和重构
  消除不必要的冗余，生成基本ER图。

#### 全局概念模式合成

* 识别局部ER图间的冲突
* 修改局部ER图
* 局部ER图合并

##### 识别局部概念模式间的冲突

各个局部应用所面向的问题不同，通常是由不同的设计人员进行局部ER图设计，所以各个局部ER图中必定存在许多不一致的地方，称之为冲突。合理消除各局部ER图的冲突时合并局部ER图的关键。各局部模式之间的冲突主要有：

* **命名冲突**
  * 同名异义
    即同一名字在不同的局部ER图中表示不同的概念。如“编号”这一名字在学生实体中表示学号，而在课程实体中表示课程号。
  * 异名同义
    即同一个概念在不同的局部ER图中使用了不同的名字。如在一个局部ER图中学生实体有“何时入学”这一个属性，在另一个局部ER图中学生实体有“入学时间”这一属性，两者是同名异义。
* **结构冲突**
  * 结构冲突是模式结构的冲突。它指相同的概念在不同的局部ER图中使用不同的概念结构来表示。
* **值域冲突**
  * 指同一个属性在不同的局部ER图中具有不同的值域定义。
  * 属性域冲突，即**属性的类型、取值范围或取值集合不同**。如属性“编号”在一个局部模式中定义为整数型，而在另一个局部模式中定义为字符型。
  * 属性取值单位冲突，如数型“身高”在一个局部模式以“厘米”为单位，在另一个局部模式中以“米”为单位。
* **约束冲突**
  * 这种冲突指两个局部模式在同一个概念上定义了不同的约束。

##### 消除冗余

* 在初步ER图中，可能存在一些冗余的数据和实体间冗余的联系。
* 所谓冗余的数据是指可由基本数据导出的数据，冗余的联系是指可由其他联系导出的联系。
* 冗余数据和冗余的联系容易破坏数据库的完整性，应当予以消除。
* 消除了冗余后的初步ER图称为基本ER图。
* 消除冗余主要采用分析方法，即以数据字典和数据流图为依据，根据数据字典中关于数据项之间的逻辑关系的说明来消除冗余。

#### 事务设计

数据库设计的目的是支持各种事务的运行。在数据库的设计中，需要考虑所有事务的特点和要求，这样才能保证所设计的数据库包含的各种事务所需要的信息。在概念数据库设计阶段，事务设计的任务是定义事务的功能，其方法是说明事务的输入、输出信息和功能。

事务可以分为三类：数据查询型事务，数据更新型事务，混合型事务。

#### 【补充】数据抽象

摘自：https://blog.csdn.net/scuzoutao/article/details/78005632

数据抽象主要是为了向用户屏蔽复杂性。一共分为三层：

1. 物理层，物理层的数据抽象主要描述了数据在物理层面是怎么存储的数据，这主要是数据库的供应商来研究的。
2. 逻辑层，逻辑层的数据抽象主要描述了数据库中存储着什么数据，这些数据之间有什么关系，这主要是开发人员或者是数据库管理员考虑的，逻辑层的用户不需要去知道我的数据具体是怎么样子存储的。
3. 视图层，在一些数据库系统中，往往数据库是非常庞大的，而我们用户只关心庞大的数据库中的某一个小部分，视图层描述着庞大的数据库中的一部分，作为一个视图，由于大型数据库中的数据非常多而且具有着多样性，这就不可避免的产生了复杂性，视图层的抽象的定义正是为了给只需要访问一部分数据库的用户提供与系统的交互的简单性。

### 7.4 逻辑结构设计

#### 任务

逻辑结构设计的任务是**把概念结构设计阶段设计好的基本ER图转换为与选用的DBMS所支持的数据模型相符合的逻辑结构。**

逻辑结构设计的目标包括：满足用户的完整性和安全性要求、动态关系至少满足第三范式，静态关系至少满足第一范式、能够在逻辑级上高效率地支持各种数据库事务的运行、存储空间利用率高。

#### 主要步骤

1. **形成初始关系数据库模式**
2. **关系模式规范化**
3. **关系模式优化**
4. **定义关系上的完整性和安全性约束**
5. **子模式定义**
6. **性能估计**

#### 关系模式的优化

##### 两种优化方法

优化关系模式的两种方法：

* 水平分解（减少记录行数）
  * 把经常使用的那一部分数据分解出来作为一个关系，其他数据作为另一个关系
  * 做法：把关系的元组分为若干子集合，定义每个子集合为一个子关系

* 垂直分解（减少属性数）
  * 经常在一起使用的属性从R中分解出来形成一个子关系模式
  * 做法：把关系模式R的属性分解为若干子集合，形成若干子关系模式

##### 逆规范化

如果经常需要对多个关系进行连接操作，且大多数操作为查询操作，更新很少，则可以考虑将这些关系合并为一个关系

##### 设计子模式

根据局部应用的需求，结合具体DBMS的特点，设计用户外模式

### 7.5 物理结构设计

#### 定义

数据库在物理设备上的存储结构和存取方法称为数据库的物理结构。

为一个给定的逻辑模型选取一个最合适应用要求的物理结构的过程，就是数据库物理设计。

#### 关系存取方法

常用的存取方法：==（B+树）索引存取方法、hash索引存取方法、聚簇存取方法==

* 索引存取方法：经常在查询条件中出现的属性，应为其建立索引。
* 聚簇存取方法：聚簇存取方法将相关的数据存放在连续的物理块中，从而提供查询的效率。
* HASH存取方法：如果一个关系的属性主要出现在相等比较条件中，且满足以下两个条件之一，则可以使用HASH存取方法：
  * 一个关系的大小可以预知，而且不变。
  * 关系的大小动态改变，但数据库管理系统提供了动态HASH存取方法

### 7.6 数据库的实施和维护

略

## 第九章 数据库存储（文件结构）

本章属“大数据班”Label的额外、补充内容

### 存储介质简介

#### 磁盘

* 磁道：盘片的表面被逻辑地划分为磁道。
* 扇区：磁道又被逻辑地划分为扇区；扇区是从磁盘读出和写入数据的最小单位，通常大小为512字节。
* 物理块：一个盘片的一条磁道内几个连续的扇区构成的序列称为物理块,一般也简称块；数据在磁盘和主存储器之间以块为单位传输。

#### RAID技术

##### 定义

RAID （Redundant Array of Independent Disks）即独立磁盘冗余阵列

RAID技术将多个单独的物理硬盘以不同的方式组合成一个逻辑硬盘，从而提高了硬盘的读写性能和数据安全性。根据不同的组合方式可以分为不同的RAID级别

##### 级别划分

| RAID级别 | 特性                                           |
| -------- | ---------------------------------------------- |
| RAID 0   | 数据条带化，无校验                             |
| RAID 1   | 数据镜像，无校验                               |
| RAID 2   | 海明码错误校验及校正                           |
| RAID 3   | 数据条带化读写，校验信息存放于专用硬盘         |
| RAID 4   | 单次写数据采用单个硬盘，校验信息存放于专用硬盘 |
| RAID 5   | 数据条带化，校验信息分布式存放                 |

##### 具体定义

* RAID0：即没有容错设计的条带硬盘阵列（Striped Disk Array without Fault Tolerance），以条带形式将RAID组的数据均匀分布在各个硬盘中
* RAID 1 定义：又称镜像（Mirror），数据同时一致写到主硬盘和镜像硬盘
* RAID 2 采用早期的**海明码**校验组成硬盘阵列。RAID中第1个、第2个、第4个……第2的n次幂个硬盘都是校验盘。
* RAID 3即带有校验的并行数据传输阵列（Paralleled transfer with parity），数据条带化分布在数据盘中，同时使用专用校验硬盘存放校验数据 
* RAID 4是带有共享校验硬盘的独立数据盘。与RAID 3类似，不同在于对数据访问是每次一个盘，而RAID 3是每次一个条带，RAID4的读写性能较差，目前较少使用
* RAID 5与RAID 3机制类似，但校验数据均匀分布在各数据硬盘上，RAID成员硬盘上同时保存数据和校验信息，数据块和对应的校验信息保存在不同硬盘上。RAID 5是**最常用的RAID方式之一**
* RAID 6 是带有两个独立分布式奇偶校验方案的独立数据硬盘。广义上讲，能够**允许两个硬盘同时失效**的RAID级别统称为RAID 6，硬盘空间利用率为(N-2)/N，N为RAID6阵列硬盘总数

另，同时采用两种不同的RAID方式还能组合成新的RAID级别。如，RAID 50是将RAID5和RAID 0进行两级组合的RAID级别，最低一级是RAID 5，第二级为RAID 0

##### 优缺点信息

RAID0

* 优点：
  * 极高的读写效率
  * 速度快，由于不存在校验，所以不占用CPU资源
  * 部署简单
* 缺点：
  * 无冗余，通常和其他RAID级别混合使用 
  * 不适合用于关键数据环境
* 最小硬盘数：2

RAID1

* 优点：
  * 提供了很高的数据安全性和可用性 
  * 100％的数据冗余
  * 设计、使用简单
  * 不作校验计算，CPU占用资源少
* 缺点：
  * 空间利用率只有1/2
  * 相对于单个硬盘，无法提高写性能
* 最小硬盘数：2

RAID5

* 优点：
  * 高读取速率，中等写速率
  * 提供一定程度的数据安全
* 缺点：
  * RAID组里单块硬盘的故障，会导致其他硬盘读写性能大幅度下降 
* 最小硬盘数：3

### 缓冲区调度

多数操作系统采用**最近未使用(LRU)的缓冲区替换策略**

特点：相对于操作系统中的虚拟存储系统，缓冲区管理支持更加复杂的功能

### 数据库文件结构

#### 文件组织类型

* 数据文件-数据库数据的物理存储. 文件是记录的序列. 记录是字段的序列.
* 定长记录文件-记录的长度是固定的
* 变长记录文件-文件中能够容纳不同长度的、不同类型的记录

#### 定长记录

简单方法：记录i 从字节n * (i – 1)开始存储, 其中n 是记录大小。

存在的问题：

* 记录存取简单, 但记录可能跨块，读写需要两个块
  * **变化: 不允许记录跨越块边界**
* 删除记录困难
  * （可选的解决方法）删除方式：自由链表

#### 变长记录

方法一：使用Slotted Page 结构存储

方法二：定长表示法（使用一个或多个定长记录表示一个变长记录）

* **预留空间法**。利用具有已知最大长度的定长记录; 较小记录中的未用空间用null或 end-of-record 符号填充.
* **指针法**。变长记录用若干通过指针链在一起的定长记录表示

#### 文件中的记录组织

不同的组织方式：

* **堆**。记录可置于文件中的任何有空间的地方
* **顺序**。记录按顺序存储, 基于每条记录在搜索码上的值
* **散列**。对记录的某属性计算散列函数; 计算结果决定该记录应该置于文件的哪个块中

每个关系的记录可存储在单独的文件中. 但在**聚簇文件组织**下, 多个关系的记录可存储于同一文件中

#### 顺序文件组织 

维护记录的物理顺序代价高

* 删除 – 利用指针链
* 插入 – 确定待插入记录的位置。若有自由空间则在该处插入；若无自由空间, 插入到溢出块

特点：**需要不时重组文件以恢复物理存储顺序，重组代价高**

#### 聚簇文件组织

* 简单的文件结构将每个关系存储在一个单独的文件中
* 利用聚簇文件组织可以将多个关系存储在一个文件中

#### 关系数据库的文件选择

* 存储关系到一个文件
  > * 优点：充分利用OS所提供的功能，减少DBMS的处理代价
  > * 缺点：DBMS的某些优化策略不支持
* 存储多个关系到一个文件（多采用）
  > * 优点：DBMS支持某些优化策略，可以在文件中设计复杂的结构
  > * 缺点：增加了数据库的大小和复杂性

#### 数据字典的存储

**数据字典**（也称为**系统目录**）保存**元数据**： 即关于数据的数据

目录结构：通常采用**关系集合, 利用现有系统特性保证高效存取**

## 第十章 索引

本章属“大数据班”Label的额外、补充内容

### 基本概念

* 索引机制用于加速对所需数据的存取
* **搜索码** – 用来在文件中查找记录的属性或属性集合.
* **索引文件**由如下形式的记录(称为索引项)组成
* 两种基本索引:
  * 有序索引: 搜索码按顺序存储
  * 散列索引: 搜索码被“散列函数” 分配到若干“桶”中. 

索引评价度量：支持的存取类型、存取插入删除时间、空间开销

### 索引分类

#### 有序索引

* **有序索引**: 索引项按搜索码值的顺序有序存储. 
* **主索引**: 顺序文件的记录顺序正是索引搜索码的顺序,也称为**聚簇索引**
  主索引的搜索码通常是主码, 但并非必要;一般而言,一个关系之上创建一个主索引
  索引顺序文件: 带有主索引的顺序文件.
* **辅助索引**: 索引搜索码的顺序与文件的记录顺序不同. 
  * 也称为**非聚簇索引**

稠密索引文件（对文件中的每个搜索码值都有索引记录）

稀疏索引（只对某些搜索码值有索引记录）

#### 多级索引

为减少对索引记录的磁盘存取次数, 将主索引视为存储在磁盘上的顺序文件并为它建立一个稀疏索引。如果外索引仍太大而不能放入内存, 还可再为它创建另一层索引, 如此类推

#### 辅助索引

可建立辅助索引, 它对每个搜索码值都有一索引记录; 索引记录指向包含具有该搜索码值的所有实际记录的指针的桶

辅助索引必须是稠密的

#### B+-树索引文件

B+-树索引文件的优点: 插入与删除时仅以较少的局部的变化来自动重组. 不需要整个文件重组来维持性能.

B+-树索引的缺点: 额外的插入与删除开销, 空间开销.

**B+-树的优点超过了缺点, 因此被广泛使用.**

（略）关于B+树的插入、删除...

#### Hash数据索引

根据搜索码的值,利用Hash函数,直接得到搜索码所在的桶

（略）关于Hash表、Hash函数、扩展Hash技术

#### 多属性索引

在多个属性之上(branch-name, balance)建立索引

#### 位图索引

位图索引是一种特殊类型的索引, 用来实现高效的多键查询。一个属性的最简单形式的位图索引对该属性的每个值都有一个位图

## 第九章 查询处理和优化

### 9.1 查询处理

关系数据库管理系统查询处理可以分为4个阶段：**查询分析、查询检查、查询优化和查询执行**

#### 查询处理步骤

1. 查询分析

   首先对查询语句进行扫描、词法分析和语法分析。

2. 查询检查

   对合法的查询语句进行语义检查,即根据数据字典中有关的模式定义检查语句中的数据库对象。还要根据数据字典中的用户权限和完整性约束定义对用户的存取权限进行检查。如果该用户没有相应的访问权限或违反了完整性约束,就拒绝执行该查询。**这时的完整性检查是初步的、静态的检查**。检查通过后便把sQL查询语句转换成等价的关系代数表达式。关系数据库管理系统一般都用**查询树**(query tree),也称为语法分析树(syntax tree)来表示扩展的关系代数表达式。

3. 查询优化

   详见9.2

4. 查询执行

   依据优化器得到的执行策略生成查询执行计划,由**代码生成器**(code generator)生成执行这个查询计划的代码,然后加以执行,回送查询结果。

### 9.2 查询优化

一般分为：**代数优化（逻辑优化）、物理优化（非代数优化）**

#### 查询优化的步骤

* 将查询转换成某种内部表示，通常是语法树。
* 根据一定的变换规则，把语法树转换为优化形式。
* 选择低层的操作算法。
* 生成查询执行计划（也称查询执行方案，是由一系列内部操作构成的）。

#### 查询优化的分类

按照优化的层次一般可将查询优化分为代数优化和物理优化。

* **代数优化**是指关系代数表达式的优化,即按照一定的规则,通过对关系代数表达式进行等价变换,改变代数表达式中操作的次序和组合,使查询执行更高效；
* **物理优化**则是指存取路径和底层操作算法的选择。选择的依据可以是基于规则(rule based)的,也可以是基于代价(cost based)的,还可以是基于语义(semantic based)的。
* 实际关系数据库管理系统中的查询优化器都综合运用了这些优化技术,以获得最好的查询优化效果

#### 查询和连接优化算法

选取运算的实现算法：**全表扫描方法、折半扫描、索引扫描**

连接操作的实现：**嵌套循环方法、排序-合并方法、索引连接方法、HASH join方法**

#### 查询代价的度量

查询代价：查询处理对各种资源的使用情况

* 总代价=I/O代价+CPU代价+通信开销
* I/O代价的度量方式：I/O块数或者次数
* 一个重要的影响因素：主存中缓冲区的大小M。（如多次运行同一算法，开始极慢，之后由于数据读入缓存，执行时飞一般的速度）

#### 一个查询优化例子

例：求选修了课程C2的学生姓名

```sql
SELECT Student.Sname
FROM Student, SC
WHERE Student.Sno=SC.Sno
AND SC.Cno='2';
```

假设:

* Student表中有1000条学生记录:$n_{student}$= 1000
* SC表中有10000条选课记录: $n_{sc}$= 10000
* 其中选修2号课程的选课记录为50条: SC(cno,SC)=50
* 一个块可以装10个Student元组或100个SC元组：$f_{student}$= 10，$f_{sc}$= 100
* Student表占用的块: $b_{student}$= 100
* SC表占用的块:$b_{sc}$= 100
* 一个块可以装10个Student和SC的连接结果元组：$f_{join}$= 10
* 缓冲: 内存中一次可以存放5块Student元组、1块SC元组和若干块连接结果元组
* 读写速度：20块/秒

##### 查询1

$$
Q_1=\prod_{Sname}(\sigma_{Student.Sno=SC.Sno}\and SC.Cno='2'(Student\times SC))
$$

1、$(Student\times SC)$块嵌套循环

* 读数据时间105s

* 中间结果大小=$10^3*10^4=10^7$（1000万条元组）
* 写中间结果时间：$5*10^4s$

总时间：$105+5*10^4+5*10^4=27.8h$

##### 查询2

$$
Q_2=\prod_{Sname}(\sigma_{SC.Cno='2'}(Student\bowtie SC))
$$

* 读数据时间105s

* 中间结果大小=$10^4$（减少1000倍）
* 写中间结果时间：$50s$

总时间：$105+50+50=205s$

##### 查询3

$$
Q3 = \prod_{Sname}(S \bowtie \sigma_{SC.Cno='2'}(SC))
$$

* 读SC表总块数$=b_{sc}=100$块
* 读数据时间=SC(Cno,SC)/20=100/20=5秒
* 中间结果大小=50条 不必写入外存
* 读S表总块数= 1000/10-100块
* 读数据时间=100/20=5秒
* 总时间：$5+5=10s$

### 9.3 代数优化

关系代数表达式的等价是指用相同的关系代替两个表达式中相应的关系所得到的结果是相同的。

两个表达式等价：产生的结果关系具有相同的属性集和相同的元组集。

#### 等价变换规则

1-10共10条规则

1-2: 连接、笛卡尔积的交换律、结合律
3： 合并或分解投影运算
4： 合并或分解选择运算
5-8：选择运算与其他运算交换
5，9，10： 投影运算与其他运算交换

#### 查询优化的一般准则

* 选择运算应尽可能先做。
  * 目的：减小中间关系。
* 在执行连接操作前对文件适当进行预处理。
  * 如排序、在连接属性上建立索引
* 投影运算和选择运算同时做。
  * 目的：避免重复扫描关系。
* 把投影运算与其前面或后面的双目运算结合起来。
  * 目的：减少扫描关系的遍数。
* 某些选择运算＋在其前面执行的笛卡尔积【转换为】连接运算
* 找出公共子表达式

#### 查询树

定义：关系代数表达式的树形表示

{一个具体的优化例子+过程} 46p42-

### 性能优化

对数据库性能影响最大的是数据库的设计和开发。

#### 优化准则

一大堆...

#### 负载测试

数据负载测试：当数据量超出了服务器内存容量好几倍的时

用户负载测试：当使用大量的用户来测试数据库时才有可能发生锁争用，会导致严重的性能问题。

清除测试的影响：数据库已经经过优化，它可以智能地将数据缓存在内存中，而这将会影响到后续测试的结果。测试前要刷新内存，这可以通过停止并重新启动服务器实现。

#### 影响性能的因素

。。。

#### 数据库设计与性能

。。。

#### 约束和触发器

。。。

#### 查询设计和性能

。。。

#### 基础索引/索引调优

。。。

#### 加锁和性能

。。。

## 第十章 数据库恢复技术

### 10.1 事务的基本概念

#### 事务定义

定义：**事务是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。**

* <u>事务与应用程序是两个概念，一般来说，一个应用程序可以包含多个事务</u>。
* 事务的开始与结束可以由用户显式控制。如果用户没有显式定义事务，则由DBMS按缺省规定自动划分事务。

#### 事务的特性（ACID）

1. **原子性(Atomicity)**
   事务是数据库的逻辑工作单位，事务中包括的诸操作要么全做，要么全不做。
2. **一致性(Consistency)**
   事务执行的结果应当使数据库从一个一致性状态转变为另一个一致性状态。
3. **隔离性(Isolation)**
   一个事务的执行不能被其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能相互干扰。
4. **持久性(Durability)**
   一个事务一旦提交之后，它对数据库的影响必须是永久的。事务提交后，系统发生故障不能改变事务的持久性。

### 10.2 数据库恢复概述

定义：数据库管理系统必须具有把数据库从错误状态恢复到某一已知正确状态的功能，这就是数据库的恢复。数据库恢复是通过**数据库管理系统的恢复子系统**完成的。

数据库恢复子系统的目的包括：

* 保证事务的原子性
* 当系统发生故障以后，数据库能够恢复到正确状态。

### 10.3 故障的种类

1. **事务内部的故障**
   * 包括可预期的和不可预期的。
   * 可预期的是指可以通过事务程序本身发现和处理的故障。
   * 而不可预期的错误是指那些不能由应用程序处理的事务故障，如死锁，运算溢出，违反完整性规则等。
2. **系统故障**
   * 系统故障是指造成系统停止运行的任何事情，使得系统要重新启动。如硬件错误，操作系统故障，停电等。
   * 恢复子系统必须清除所有未完成的事务对数据库的修改，同时重做所有已完成的事务，保证数据库的一致性。
3. **介质故障**
   * 介质故障指外存故障，如磁盘损坏，瞬时强磁场干扰等。这类故障将破坏全部或部分数据库，并影响正在存取这部分数据的所有事务。
4. **计算机病毒**
   * 一种人为的破坏或故障

### 10.4 恢复的实现技术

数据库恢复的基本原理为**冗余**。如果数据库中任何一部分数据被破坏或处于不正确的状态，则可以通过存储在系统别处的冗余数据来重建。

建立冗余的常用方法：**数据转储、登记日志文件**

#### 数据转储

##### 定义

转储即DBA定期地将整个数据库复制到磁带或其它存储设备上保存起来的过程。这些备用的数据文本称为<u>后备副本</u>或后援副本。

##### 转储的分类

* **静态转储**
  静态转储是在系统中<u>无事务运行时进行</u>的转储操作。即转储开始时数据库处于一致状态，转储过程中，不允许对数据库的任何存取、更新活动

* **动态转储**
  动态转储是指<u>转储期间允许对数据库进行存取或修改</u>，即转储和用户事务可以并发执行。动态转储克服了静态转储的缺点，但除了转储数据库的数据以外，还必须把转储期间各事务对数据库的修改记录下来，这样才能保证把数据库恢复到某一时刻的一致状态。

##### 转储的方式

* **海量转储**
  海量转储指每次转储<u>全部</u>数据库。
* **增量转储**
  增量转储指每次<u>只转储上一次转储后更新过的数据</u>。

根据分类+方式可分为4类：动态海量转储、动态增量、静态海量、静态增量

#### 登记日志文件

##### 定义

定义：日志文件是**用来记录事务==对数据库的更新操作的文件==**。日志文件主要有两种格式：<u>以记录为单位的日志文件</u>、<u>以数据块为单位的日志文件</u>。

* 以记录为单位的日志文件记录的内容包括：
  * 各个事务的开始标记
  * 各个事务的结束标记
  * 各个事务的所有更新操作
* 对于以数据块为单位的日志文件，日志记录的内容包括事务标识以及**更新**前和更新后的数据块。

##### 日志文件的作用

日志文件可以用来进行事务故障恢复和系统故障恢复，并协助后备副本进行介质恢复。其具体作用是：

1. 事务故障和系统故障恢复必须使用日志文件。
2. 在动态转储方式中必须建立日志文件，后备副本和日志文件综合起来才能保证备份的一致性，和有效地恢复数据库。
3. 静态转储方式中，也可以建立日志文件。当数据库发生故障时，用后援副本把数据库恢复到转储结束时的正确状态，然后利用日志文件重做已完成的事务，把数据库恢复到故障前的正确状态。

##### 登记的原则

为保证数据库是可恢复的，登记日志文件时必须遵循两条原则：

1. 登记的次序严格按并发事务执行的时间顺序。
2. 必须先写日志文件，后写数据库。

### 10.5 恢复策略

事务、系统仅需日志，介质再需转储（提供期间的操作）

* 在进行数据库系统故障的恢复时，对于已提交的事务应当进行==REDO操作==，对于未提交的事务应当进行==UNDO操作==。

#### 事务故障的恢复

事务故障是指**事务在运行至正常终止点之前被终止**。事务故障的恢复是由系统自动完成的。具体步骤：

做法：UNDO，撤销事务，在不影响其他事务的情况下强行回滚。反向扫描日志，执行所有更新操作的逆操作。

#### 系统故障的恢复

系统故障造成数据库不一致状态的原因有两个

* 一是未完成的事务对数据库的更新可能已经写入数据库；
* 二是已提交事务对数据库的更新可能还留在缓冲区还没来得及写入数据库。

因此恢复操作就是要<u>撤销故障发生时未完成的事务，重做已完成的事务</u>。

做法：UNDO+REDO，撤销故障发生时未完成的事务，重做已完成但没有写入数据库的事务。

#### 介质故障的恢复

介质故障将全部或部分地破坏数据库甚至是日志文件，其恢复的方法是：

* 装入最新的数据库后备副本（离故障发生时刻最近的转储副本），使数据库恢复到最近一次转储时的一致状态。对于动态转储的副本，还需要装入转储开始时刻的日志文件副本，将数据库恢复到一致状态。
* **装入转储以后的日志文件副本，重做已经完成的事务**。

做法简单概括：装入最新数据库后备副本，使数据库恢复到最近一次转储时的一致状态。装入转储以后的日志文件副本，重做已经完成的事务。

#### 更新技术

推迟更新技术：所有日志记录完才更改数据库。所有对数据库的更新操作推迟到该事务提交时执行

即时更新技术：每执行1sql语句更新数据库。允许事务直接更新数据库

### 10.6 具有检查点的恢复技术

这种技术在日志文件中增加一类新的记录－检查点（checkpoint）记录，增加一个重新开始文件，并让恢复子系统在登录日志文件期间动态地维护日志。

检查点记录的内容包括：。。。

动态维护日志文件的方法是周期性地执行如下操作：。。。

系统用检查点方法进行恢复的步骤是：。。。

### 10.7 数据库镜像

根据DBA要求，自动把整个数据库或其中的关键数据复制到另一个磁盘上。每当主数据库更新时，DBMS自动把更新后的数据复制过去，即DBMS自动保证镜像数据与主数据的一致性。

## 第十一章 并发控制

### 11.1 并发控制概述

#### 优点

* 一个事务多个步骤并发执行，**提高系统吞吐量**，改善资源利用率。
* 如果各个事务涉及的是数据库的不同部分，采用并发会**减少平均响应时间**。

#### 并发执行的问题

1. **丢失修改**：两个事务T1和T2读入同一数据并修改， T2提交的结果破坏了T1提交的结果，导致T1的修改被丢失。
2. **不可重复读**：事务T1读取某一数据后，事务T2对其做了修改，当事务T1再次读取该数据时，得到与前一次不同的值。
3. 不可重复读之幻影行：事务T2删除或插入一些记录
4. **读“脏”数据**(Dirty Read) ：是指事务T1修改某一数据，并将其写回磁盘，事务T2读取同一数据后，T1由于某种原因被撤销，这时T1已修改过的数据恢复为原值，T2读到的数据就与数据库中的不一致，则T2读到的数据就为“脏”数据。

#### 进行并发控制的原因

* 如果不进行并发控制，当多个事务并发执行的时候，有可能会相互影响，从而读取或者存储不正确的数据，破坏数据库的一致性。

造成并发执行事务问题的原因是：

* 多个事务同时存取同一个数据集合
* 并且其中至少有一个事务对该数据集合进行了更新操作

### 11.2 封锁

解决问题的思路：合理调度并发事务，避免并发事务之间的互相干扰造成数据的不一致性。主要方法是**封锁机制**。

#### 定义

封锁就是事务T在对某个数据对象如表、记录等操作之前，先向系统发出请求，对其加锁，从而对该数据对象有了一定的控制，在事务T释放它的锁之前，其他事务不能更新此数据对象。

#### 封锁的类型

* 排它锁（X锁，eXclusive lock）：事务T对数据对象A加上X锁，则<u>只允许T读取和修改</u>A，其它事务对A的任何封锁请求都不能成功（因而不能读取和修改R），直至T释放A上的X锁。
* 共享锁（S锁，Share lock）：事务T对数据对象A加上S锁，则<u>事务T可以读取但不能修改</u>A，<u>其它事务只能对A加S锁（因而可以读取A），而不能对A的加X锁</u>（因而不能修改A），直到T释放A上的S锁。

### 11.3 封锁协议

运用两种基本封锁可以建立不同的约定，形成不同级别的封锁协议。

* 一级封锁协议：<u>防止丢失修改</u>。在修改数据R之前加X锁，结束才可以释放。
* 二级封锁协议：<u>防止丢失修改+读脏数据</u>。一级封锁协议加上在读取R之前必须加S锁，<u>读完释放</u>S锁。
* 三级封锁协议：<u>防止丢失修改+读脏数据+不可重复读</u>。一级封锁协议加上读取R前必须加S锁，直到<u>事务结束才可以释放</u>。

### 11.4 死锁与活锁

#### 死锁

##### 预防死锁

* ==一次封锁法==：要求每个事务必须一次将其所有要使用的数据全部加锁，否则就不能执行。可以有效地防止死锁的发生，但由于需要扩大加锁的范围，降低了系统的并发度。
* ==顺序封锁法==：预先对数据对象规定一个封锁顺序，所有事务都按照这个顺序封锁，实现难度大。

##### 死锁检测

* 超时法：如果等待时间超过时限就认为发生死锁。
* 等待图法：图中有回路说明出现了死锁。

##### 死锁恢复

通常采用的方法是选择一个处理死锁代价最小的事务，将其撤销，释放此事务持有的所有锁，使其他事务得以继续运行下去。对于所撤销的事务所作的操作必须加以恢复。

一般选执行时间最短的（最常用）；或持有资源最少

### 11.5 并发调度的可串行性

* 串行调度：在串行调度中，属于同一事务的指令紧挨在一起。
* 并行调度：来自不同事务的指令可以交叉执行。

#### 可串行性调度

定义：**多个事务的并发执行是正确的，当且仅当其结果与按某一次序==串行执行==它们时的结果相同**，我们称这种调度策略为可串行化调度。一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度。举例：

事务T1:

> 读B;
> A=B+1;
> 写回A

事务T2:

> 读A;
> B=A+1;
> 写回B;

#### 冲突可串行化调度

冲突操作：指不同事务对同一数据的读写操作和写写操作

### 11.6 两段锁协议

1. 在对任何数据进行读、写操作之前，事务首先要获得对该数据的封锁。
2. 在释放一个封锁之后，事务不再获得任何其它封锁。

**定理：若所有事务均遵从两段锁协议，则这些事务的所有并行调度都是可串行化的**

* 不符合两端锁协议也可能”可串行性调度“，充分条件。如p50不符合，但没问题
* 符合两端锁协议也可能死锁，如p52页的情况

#### 多粒度封锁

核心思想是灵活调整粒度，如一些内容可以开放给其他进程使用，班级、同学等数据范围

**粒度：封锁对象的大小称为封锁的粒度。**

粒度大，则并发度低，封锁机构简单，开销小。

粒度小，则并发度高，封锁机构复杂，开销高。

**多粒度封锁**：如果在一个系统中同时支持多种封锁粒度供不同的事务选择是比较理想的，这种封锁方法称为多粒度封锁（Multiple Granularity Locking）。选择封锁粒度时应同时考虑封锁开销和并发度两个因素，适当选择封锁粒度以达到最优效果。

**多粒度封锁协议**：允许多粒度树中每个结点被单独加锁，对一个结点加锁意味着所有后裔结点也被加以同样类型的锁。

**多粒度树**：多粒度树的根结点是整个数据库，表示最大的粒度。叶结点表示最小的粒度。

* 在多粒度封锁中一个数据对象可能以两种方式封锁，即：
  * <u>显式封锁</u>是应事务的要求直接加到数据对象上的封锁。
  * <u>隐式封锁</u>是该数据对象没有独立加锁，是由于其上级结点加锁而使该数据对象加上了锁。

#### 意向锁

一般的，对某个数据对象加锁，系统要检查该数据对象上有无显式封锁与之冲突；还要检查其所有上级结点，看本事务的显式封锁是否与该数据对象上的隐式封锁冲突；还要检查其所有下级结点，看上面的显式封锁是否与本事务的隐式封锁冲突。效率很低，因此引入了意向锁。

##### 定义

**意向锁**：如果对一个结点加意向锁，则说明该结点的下层结点正在被加锁；对任一结点加锁时，必须先对它的上层结点加意向锁。好处是，对象加锁时，不需要再检查下级结点的封锁。

##### 三种常用的意向锁

* 意向共享锁（Intent Share Lock，简称IS锁）
  如果要对一个数据对象加IS锁，表示它的后裔结点拟（意向）加S锁。
* 意向排它锁（Intent Exclusive Lock ，简称IX锁）
  如果要对一个数据对象加IX锁，表示它的后裔结点拟（意向）加X锁。
* 意向共享排它锁（ Share Intent Exclusive Lock ，简称SIX锁）
  如果要对一个数据对象加SIX锁，表示对它加S锁，再加IX锁，即SIX=S+IX。

【注】

* 由于意向锁IS、IX、SIX表示后裔节点，因此同一节点可同时加IS、IX
  锁并不冲突，因为可表示的为一个子结点IS、另一个IX

* SIX例子 58分？

## 第十四章 分布式数据库

### 概述

#### 定义

分布式数据库是由一组数据组成的，这组数据分布在计算机网络的不同计算机上，网络中每个结点具有独立处理的能力（称为场地自治），可以执行局部应用（只对本结点数据进行存取的应用），同时每个结点也能通过网络通讯支持全局应用（指存取两个或两个以上的结点的数据库应用）。

* 分布式数据库==强调场地自治性（局部应用）以及自治场地之间的协作性（全局应用）==。

#### 分布式数据库特点

分布式数据库具有以下两个特点：

1. **分布性**
   分布性有两层含义，一是指数据库中的数据不是都存储在同一结点（更确切的讲，不存储在同一计算机的存储设备上），而是分布在多个结点上；二是指各结点具有独立的数据库处理能力，能够有效地支持局部应用。
2. **逻辑整体性**
   分布在各结点的数据不是孤立的，而是相互联系的，是一个逻辑整体，能够支持存取多个结点数据的全局应用。

#### 分布式数据库系统特点

1. **数据独立性**
2. **集中与自治相结合的控制机构**
3. **适当增加数据冗余**
4. **全局的一致性、可串行性和可恢复性**

#### 分布式数据库系统的目标

* 适应部门分布的组织结构，降低费用
* 提高系统的可靠性和可用性
* 充分利用数据库资源，提高现有集中式数据库的利用率
* 逐步扩展处理能力和系统规模

### 分布式数据库的体系结构

#### 模式分类

* 全局外模式：全局应用的用户视图，是全局概念模式的子集。
* 全局概念模式：定义分布式数据库中数据的整体逻辑结构，使得数据如同没有分布一样。
* 分片模式：每一个全局关系可以分为若干互不相交的部分，每一部分称为一个片段。分片模式定义片段以及全局关系到片段的映像。
* 分布模式：定义片段的存放结点。

#### 分布（网络）透明性

分布透明性包括：==**分片透明性、位置透明性、局部数据模型透明性**==

* **分片透明性**：用户或应用程序只对全局关系进行操作而不必考虑关系的分片。如果分片模式改变了，通过调整==全局模式与分片模式==之间的映象关系来保持全局模式不变。
* **位置透明性**：用户或应用程序不必了解片段的存储位置。
* **局部数据模型透明性**：用户或应用程序不必了解局部场地上使用的是哪种数据模型。

例子：

* 分布独立性 select * From S
* 不具有分片透明性：Select * From S_A
* 不具有位置透明性：Select * From S_B@Site2

（示例：设有全局关系S，它被划分为两个片段S-A（本科生），S-B（研究生），S-B有两个副本。见p14）

### 分布式数据库设计

#### 数据的存储途径

分为：重复存储、分片存储、组合存储

#### 重复存储

系统在两个或两个以上结点维护关系R的几个完全相同的副本。

#### 分片存储

关系被划分为几个片段，各个片段存储在不同的结点上。将数据分片，使数据存放的单位不是关系而是片段，这既有利于按照用户的需求较好地组织数据的分布，也有利于控制数据的冗余度。

分片时必须遵循以下原则：

* 完全性：被划分关系中的每个元组必须属于一个片段。
* 不相交性：同一个关系的片段互不相交。
* 可重构性：如果R被划分为片段R1、R2、、Rn，则R能从R1、R2、、Rn恢复出来。

#### 分片方式

##### 水平分片

将关系r依照一定条件按行分为不相交的若干子集$r_1,r_2,...,r_n$，每个子集$r_i$称为一个水平片段。
一个水平片段可以看成是关系上的一个选择：
$$
r_j = \sigma_{P(i)}(r)
$$
关系的重构可以通过并运算来实现
$$
r = r_1 \cup r_2...\cup r_n
$$

##### 垂直分片

将关系r按列分为若干属性子集$r_1,r_2,...,r_n$，每个子集$r_i$称为一个垂直片段。

关系的重构可以通过连接运算来实现
$$
r = r_1 \bowtie r_2...\bowtie r_n
$$
* **所有分片都包括关系的码**

##### 导出分片

* 导出水平分片，分片的条件不是关系本身属性条件，而是其它关系的属性条件。
* 如SC（SNO，CNO，G）按学生系别分片。

##### 混合分片

* 关系按某种方式分片后，得到的片段再按另一种方式继续分片。
* 如SC（SNO，CNO，G）按学生系别分片，再对每个片段按成绩（及格，不及格）分片。

#### 组合存储

这种方法是重复存储和分片存储相结合的方法。关系被划分为几个片段，系统为每个片段维护几个副本，每个副本存放于不同的结点上。

#### 命名和局部自治性

每个数据项（关系、副本、片段）必须有唯一的名字，在分布式数据库系统中必须保证在不同的结点上不会用同一个名字来代表不同的数据项。

（如重复的”刘洋“名字）

途径1：名字服务器

* 所有名字都在名字服务器中注册，每个名字对应一个数据项。（判定名字是否唯一）
* 缺陷：名字服务器成为名字解析的瓶颈；其故障将影响整个系统的运行；局部自治性降低。

途径2：将结点标识作为前缀加到该结点数据项的名字前面。使用这一方法，能够保证名字的唯一性，不须中央控制，局部自治性提高；但不能保证**网络透明性**。（破坏了分布透明性）

### 分布式数据库管理系统

#### D-DBMS的组成

D-DBMS由四个部分组成：

* **LDBMS**，局部场地上的DBMS，主要功能是建立和管理局部数据库，提供场地自治能力，执行局部应用以及全局查询的子查询。
* **GDBMS**，全局数据库管理系统，主要功能是提供分布透明性，协调全局事务的执行，协调各局部DBMS以完成全局应用，保证数据库的全局一致性，执行并发控制，实现更新同步，提供全局恢复等功能。
* **全局数据字典**，存放全局概念模式、分片模式、分布模式等的定义，以及各模式之间的映像定义，存放有关用户存取权限的定义、完整性约束的定义等。
* **通信管理**，在分布式数据库各场地之间传送消息和数据，完成通信功能。

#### D-DBMS的分类

* 按全局控制发生分类
  * 全局控制集中的DDBMS
  * 全局控制分散的DDBMS
  * 全局控制部分分散的DDBMS
* 按局部DBMS的类型分类
  * 同构型DDBMS
  * 异构型DDBMS

### 分布式查询处理

在分布式数据库系统中，数据分布在网络上的多个结点之中，其查询需要由多个结点利用网络协作完成。

#### 查询处理过程

分布式查询处理的过程包括：

* **查询变换**
  * 将用户查询转换为析取范式或合取范式，并进行语义分析，检查查询的正确性等工作。
* **数据定位**
  * 数据定位的目的是把用户定义在全局概念模式上的查询转换为定义在局部概念模式上的查询。
* **全局查询优化**
  * 全局查询优化时需要选择执行操作的顺序，降低网络通信的开销。
* **局部查询优化**
  * 局部查询优化的目的是为每个局部查询选择优化的执行计划，其方法与集中式数据库的查询优化策略和方法相同。

#### 一个例子

传送时间T=总传输延迟+总数据量/传输速度

1. 把关系P从B站传送到A站，在A站进行查询

2. 把关系S，SP从A站传送到B站，在B站进行查询

   传送时间 $T=2+(10^4+10^6)*100/10^4\approx 10^4s$

3. 在A站连接S与SP，选出城市为北京的元组（假定有105个），然后对其中每个元组的P#，询问B站，看其是否为红色。
   传送时间 $T=2*10^5s$

4. 在B站选出红色零件（假定有10个），然后对每个元组询问A站，看北京的供应商是否供应此零件。
   传送时间 $T=2*10=20s$

5. 在A站选出北京的供应商（105个），传送到B站，在B站完成查询。
   传送时间 $T=1+ 10^5*100/10^4=10^3s$

6. 在B站选出红色零件（10个），把结果传送到A站，在A站完成查询。
   传送时间 $T=1+10*100/10^4=1.1s$

#### 半连接运算

##### 定义

定义：半连接
$$
R\ltimes S=\pi_R（R\bowtie S）
$$

* 相当于自然连接+仅取R中的列

##### 半连接作用

找出R中能够与S中元组相连接的元组来，类似于在连接之前先做选择和投影。
$$
R\bowtie S = (R\ltimes S)\bowtie S\\
R\bowtie S = (S\ltimes R)\bowtie R
$$
半连接的非对称性：
$$
R \ltimes S \neq S \ltimes R
$$

#### 通讯代价模型

$$
TC(X)=C_0+X*C_1
$$

* 其中X为数据传输量。
* C0为两结点初始化一次传输所花费的开销。
* C1为传输率，即单位数据传输所花费的时间。

采用半连接的通讯代价：
$$
C_{SJ}=2C_0+(size(R')*card(R')+size(S)*card(S'))*C_1
$$
不采用半连接的通讯代价：
$$
C_{JN}=C_0+size(S)*card(S)*C_1
$$
当S中参与连接的元组足够少时采用半连接策略是有利的。

### 分布式事务处理

数据的分布导致事务具有了分布性。一个全局事务的执行被划分为在许多结点上子事务的执行。系统不但要保证每个子事务的原子性，还要保证全局事务的原子性。这需要在结点间进行协调。

#### 分布式事务处理器

事务管理器TM：管理那些访问存储在一个局部结点中的数据的事务。事务可以是局部事务，也可以是全局事务的一部分。

事务协调器TC：协调该结点上发起的各事务（局部的或全局的）的执行。

事务管理器功能

* 维护一个用于恢复的日志。
* 参与适当的并发控制模式，以协调在该结点上执行的事务的并发执行。

事务协调器功能

* 启动事务的执行。
  * 将事务分解为若干子事务，并将子事务分派到适当的结点上去执行。
  * 协调事务的终止，保证事务在所有的结点上都提交或都中止。

一个全局事务的各个子事务要么全部执行，要么全部中止。

#### 事务两阶段提交协议

​	假定事务T在结点Si发起

阶段1：。。。；阶段2：。。。

### 分布式并发控制技术

* 分布式锁技术

若分布式数据库中**没有重复存储的数据**（一份数据仅一份来管理），可以采用如下的分布式锁技术：每个结点保留一个局部锁管理器，处理对存储在本地的数据加锁和释放锁的请求。当事务T希望对结点Si上的数据项Q加锁时，T简单的向结点上的锁管理器发出一个加锁请求。分布式锁技术具有实现简单的特点，它处理一个加锁请求需要两次通信，处理释放锁请求需要一次通信。但其死锁处理较为复杂。

* 集中式锁技术

集中式锁技术仅有一个锁管理器，这个锁管理器位于唯一一个结点（如Si）上。所有的加锁和释放锁的请求都在该结点上处理。集中式锁技术具有以下优点：
实现简单 加锁请求需要两次通信，释放锁请求需要一次通信。
死锁处理简单 可按照集中式数据库的方法进行处理
集中式锁技术具有以下缺点：
瓶颈问题 Si是一个锁管理瓶颈
脆弱性 如果Si出现故障，系统无法正常运行。

* 混合锁技术

混合锁技术是集中式和分布式锁技术的折中。这种技术设置多个锁管理器，每个锁管理器管理一组数据的加锁和释放锁的请求。每个锁管理器位于不同的结点上。

* 以多为主的锁协议
* 区分锁类型的锁协议
* 主副本锁协议

#### 分布式死锁处理

在分布式方法中，所有结点对于死锁检测具有相同的职责。每个结点都根据系统的动态行为构造一个全局等待图的子等待图。
