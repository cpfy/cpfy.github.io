# 数据库系统原理

## 第一章 数据库系统概述



## 第二章 关系数据库

关系模型是关系数据库系统的基础，它由以下部分组成：

* 数据结构：关系（二维表）。关系模型的数据结构非常单一，无论是实体还是实体间的联系均由关系表示。
* 完整性约束：包括关系模型所要求的完整性约束（实体完整性约束，参照完整性约束），以及应用领域需要遵循的用户定义完整性约束。
* 关系操作：包括：选择、投影、连接、除、并、交、差等查询操作和增加、删除、修改操作两大部分。其特点是集合操作方式，操作的对象及结果都是集合。
* 关系数据语言：
  * 关系代数：用对关系的运算来表达查询，需要指明所用操作。
  * 关系演算：用谓词来表达查询，只需描述所需信息的特性。
    * 元组关系演算：谓词变元的基本对象是元组变量。
    * 域关系演算：谓词变元的基本对象是域变量。
  * SQL语言









## 第三章 SQL语言

### SQL概述

#### 特点

* 综合统一
  集数据定义，数据操纵，数据查询和数据控制于一体。
  单一的结构----关系，带来了数据操作符的统一。
* 高度非过程化
     用户只需提出“做什么”，无须告诉“怎么做”，不必了解存取路径。
* 面向集合的操作方式
  操作的对象和操作的结果均为集合。
* 以同一种语法结构提供两种使用方式
     SQL既是自含式语言，又是嵌入式语言

#### 概念

* 基本表
  是本身独立存在的表，一个（或多个）基本表对应一个存储文件
* 存储文件
  由数据块构成的存储空间，用于存储基本表、索引等。其逻辑结构组成了关系数据库的内模式
* 视图
  是从一个或几个基本表中导出的表，其本身不独立存储于数据库中

### SQL数据查询功能

查询语句SELECT

分类包括：

#### 单表查询

ppt（p13-23）

聚集函数

* Count() 求元组个数
* Sum() 对数值列求总和
* Avg() 求数值列的平均值
* Max() 求最大值
* Min() 求最小值

#### 连接查询

ppt（p24-28）

连接条件：连接查询中用来连接两个表的条件称为连接条件或连接谓词

#### 嵌套查询

ppt（-p36例子）

#### 集合查询

insert、delete、update语句

### SQL数据定义功能

#### 定义、删除、修改基本表

定义 Create Table 、

修改 Alter Table、

删除 Drop Table 

#### SQL92的数据类型

char（n）：固定长度的字符串。
varchar（n）：可变长字符串。
int：整数。
smallint：小整数类型。
numeric（p，d）：定点数共p位，小数点右边q位。
Real, double precision ：浮点数与双精度浮点数,精度与机器有关。
Float(n)：n位的精度浮点数。
date：日期（年、月、日）。
time：时间（小时、分、秒）。
interval：两个date或time类型数据之间的差

#### 完整性约束

NULL/NOT NULL
UNIQUE
PRIMARY KEY
FOREIGN KEY
CHECK

#### 定义、删除视图

视图的定义
视图是由一个或几个基本表（或视图）导出的表，数据库不存储视图所对应的 数据，而仅在 数据字典中存储其定义，因此，也称视图为虚表。视图一经定义，就可以像基本表一样被查询和删除。
视图的作用
能够简化用户操作
使用户能够以多种角度看待同一数据
对重构数据提供了一定程度的逻辑独立性
能够对机密数据提供安全保护

创建视图：Create View 
删除视图：Drop View 

### SQL数据更新功能

### 嵌入式SQL

许多事务处理都是过程性的，需要根据不同的条件执行不同的任务，单纯使用SQL语言较难实现。
实际的应用系统是非常复杂的，数据库访问只是其中一个部件。有些动作如与用户交互、图形化显示数据等只能用高级语言实现。
嵌入式SQL分为：预编译方式和函数方式。



好像没怎么讲

## 第四章 数据库的安全性

**数据库的安全性**：是指保护数据库以防止不合法的使用所造成的数据泄漏、更改和破坏。

### 数据库安全性控制

#### 常用方法与技术

* 用户身份鉴别
* 多层存取控制
* 审计
* 视图和数据加密

#### 存取控制

存取控制可以分为：

* **自主存取控制**(discretionary access control，简称DAC)。用户对于不同的数据对象拥有不同的存取权限，不同的用户对同一对象也有不同的权限，而且用户还可以将其拥有的权限转授给其他用户。
* **强制存取控制**(mandatory access control，简称MAC)。每一个数据对象被标以一定的密级，每一个用户也被授予某一个级别的许可证。对于任一个对象，只有具有合法许可证的用户才可以存取。

#### 角色与用户组

为了管理数据库特权的方便，数据库还支持角色和用户组的概念。

* **角色**是一组权限的集合，可以把它授予用户或其他角色。当把某个角色授予用户（或角色）或从用户（或角色）处收回时，就同时授予或收回了该角色代表的全部权限。
* **用户组**是一组具有相同特性用户的集合。在授权或收回权限时，可以以用户组为单位进行。

### SQL语言权限操作

#### 授予权限

* 每一个用户都拥有自己定义的数据库对象如（基本表、视图等），除了他自己和拥有DBA权限的用户以外，其他用户都不能访问这些数据库对象。如果想和其他用户共享其中一部分数据库对象，就必须将这些数据库对象上的部分或全部权限授予其他用户。其语法格式为：

```sql
Grant ALL| <权限> [{,<权限>}]
       On <表名> | <视图名> [{,<表名> | <视图名>}]
       To {<用户> [{, <用户>}] | public}
       [With Grant Option]

```

#### 回收权限

* 收回权限时，若该用户已将权限授予其它用户，则也一并收回。

```sql
Revoke ALL|<表级权限> [{,<表级权限>}] 
  On <表名>|<视图名> [{,<表名> | <视图名>}] 
  From {<用户>[{,<用户>}]|PUBLIC}例：收回Liming对Student表的全部权限
Revoke ALL On Student From Liming;
```

## 第五章 数据库的完整性

### 完整性定义

**数据库的完整性**：指数据的正确性和相容性

* 正确性是指数据应具有合法的类型，如数值型的字段只能含有0~9，不能包含其它符号；更进一步，数据还应在有效的取值范围之内，如一年最多只有12个月，不能出现13个月。
* 相容性是指表示同一个事实的两个数据应该相同，如一个人不应当存在两个年龄。数据库能否保持完整性关系到数据库系统是否能够真实的反映现实世界，因此维护数据库的完整性十分重要

### 完整性约束条件

**数据库完整性约束条件**：施加在数据库数据之上的语义约束条件

完整性约束条件作用的对象可以是关系、元组、列三种

* 列约束主要是列的类型、取值范围、精度等约束条件。
* 元组的约束是元组中各个字段间联系的约束。
* 关系的约束是若干元组间、关系集合上以及关系之间的联系的约束

涉及这三类对象的完整性约束又可分为静态约束和动态约束

* 静态约束是指数据库每一确定状态（在某一时刻数据库中的所有数据实例构成了数据库的一个状态）时，数据对象所应满足的约束条件，它是反映数据库状态合理性的约束。
  * 固有约束
    指数据模型固有的约束，如关系的属性应当是原子的。
  * 隐含约束
    指隐含于数据模式的约束，一般用DDL语句说明，并存于数据字典中。如实体完整性约束。
  * 显式约束
    指固有约束，隐含约束之外，依赖于数据的语义和应用，需要显式定义的完整性约束
* 动态约束是指数据库从一种状态转变为另一种状态时，新、旧值之间所应满足的约束条件，它是反映数据库状态变迁的约束

### 数据库的完整性控制机制

#### 数据库（RDBMS）的完整性控制机制的功能

书的版本（p156）

1. 提供定义完整性约束条件的机制
2. 提供完整性检查的方法
3. 进行违约处理

PPT版本（第四章-p47）

1. 定义功能，提供定义完整性约束条件的机制。
2. 检查功能，检查用户发出的操作请求是否违背了完整性约束条件。
3. 违约响应，若违背了完整性约束条件，则采取一定措施来保证数据的完整性。

#### 完整性检查的时机

* 立即执行约束：指在执行用户事务的过程中，在一条语句执行完后立即进行完整性约束的检查。若违背了完整性约束，系统将拒绝该操作。
* 延迟执行约束：指在整个用户事务执行完毕后，再进行完整性约束的检查，若正确方允许提交事务。若违背了完整性约束，系统将拒绝整个事务。

#### 完整性规则

一条完整性规则可以用一个五元组（D，O，A，C，P）来描述，其中：

* D（Data）约束所作用的数据对象
* O（Operation）触发完整性检查的数据库操作，即当用户发出什么操作请求时需要检查该完整性规则，是立即检查还是延迟检查。
* A（Assertion）数据对象必须满足的断言或语义约束。
* C（Condition）选择A作用的数据对象值的谓词。
* P（Procedure）违反完整性规则时触发的过程。

#### 隐含约束

* 实体完整性和其他用DDL定义的约束：Insert 或者Update时检查。若违反，则拒绝相应操作

* 参照完整性：Insert、Update、Delete时检查

  | 被参照表           | 参照表             | 违约处理               |
  | ------------------ | ------------------ | ---------------------- |
  | 可能破坏参照完整性 | 插入元组           | 拒绝                   |
  | 可能破坏参照完整性 | 修改外码值         | 拒绝                   |
  | 删除元组           | 可能破坏参照完整性 | 拒绝/级联删除/设为空值 |
  | 修改主码值         | 可能破坏参照完整性 | 拒绝/级联更新/设为空值 |

#### 显式完整性约束的说明

* 用过程说明约束
* 用断言说明约束
* 用触发器表示约束

## 第六章 关系数据理论

### 候选码的求解

ppt中缺失此部分（摘自：https://blog.csdn.net/zhang1213885531/article/details/80961983）

#### 属性分类

对于给定的关系R（A1，A2，…An）和函数依赖集F，可将其属性分为4类：

* L类  仅出现在函数依赖左部的属性。
* R 类  仅出现在函数依赖右部的属性。
* N 类  在函数依赖左右两边均未出现的属性。
* LR类  在函数依赖左右两边均出现的属性。

#### 定理与推论

* 定理：对于给定的关系模式R及其函数依赖集F，若X（X∈R）是L类属性，则X必为R的任一候选码的成员。
* 推论：对于给定的关系模式R及其函数依赖集F，若X（X∈R）是L类属性，且X+包含了R的全部属性；则X必为R的唯一候选码。
* 定理：对于给定的关系模式R及其函数依赖集F，若X（X∈R）是R类属性，则X不在任何候选码中。
* 定理：对于给定的关系模式R及其函数依赖集F，若X（X∈R）是N类属性，则X必包含在R的任一候选码中。
* 推论：对于给定的关系模式R及其函数依赖集F，若X（X∈R）是L类和N类组成的属性集，且X+包含了R的全部属性；则X是R的唯一候选码。

#### 算法步骤

1. 将R 的所有属性分为L、R、LR 和N 四类，并令X 代表L、N 类，Y 代表LR 类。 
2. 求X+。若X+包含了R 的全部属性，则即为R 的唯一候选码，转（5）；否则，转（3）。
3. 在Y 中取一属性A，求（XA）+ ，若它包含了R 的全部属性，则是候选码，转（4）；否则，调换一属性反复进行这一过程，直到试完所有Y 中的属性。 
4. 如果已找出所有候选码，则转（5）；否则在Y 中依次取2 个、3 个、…，求它们的属性闭包，若其闭包包含R 的全部属性，则是候选码。 
5. 结束

#### 求解候选码例题

【第六章作业-第4题】设有关系模式$R(ABCDE)$，其函数依赖集$F=\{A\rightarrow BC, CD\rightarrow E, B\rightarrow D, E\rightarrow A\}$

* 一种解法：A、B、C、D、E均在LR中，逐个尝试A-E，发现A与E可为候选码；

  对BCD两两组合尝试，发现$(B,C)$与$(C,D)$均可构成候选码，有依赖$B\rightarrow D$故不考虑$(B,D)$

* 候选码有4个：即$A,E,(B,C),(C,D)$

### 函数依赖集的最小覆盖

#### 定义

函数依赖集的等价性：函数依赖集F，G，若F+= G+，则称F与G等价

最小依赖集（最小覆盖）：满足下列条件的函数依赖集F称为最小覆盖，记作$F_m$：

+ F中任一函数依赖的右部仅含有一个属性
+ 不存在传递函数依赖：F中不存在这样的函数依赖$X\rightarrow A$，使得F与$F-\{X\rightarrow A\}$等价。
+ 不存在部分函数依赖：F中不存在这样的函数依赖$X\rightarrow A$，在X中有真子集Z，使得F与$F-\{X\rightarrow A\} \cup \{ Z \rightarrow A \}$等价

#### 求解算法

算法：（求解函数依赖集F的最小覆盖$F_m$）

1. 【将F中的所有依赖右边化为单一元素】：若$X\rightarrow Y$且$Y=A_1A_2...A_k(k\geq 2)$，用诸$X\rightarrow A_i$代替Y；
2. 【去掉F中的所有依赖左边的冗余属性】：逐个检查F中各函数依赖$X\rightarrow A$，令$G = F-\{X\rightarrow A\}$，若$A\in X_G^+$，则从F中去掉该函数依赖。
3. 【去掉F中所有冗余依赖关系】：逐个检查F中各函数依赖$X\rightarrow A$，设$X = B_1...B_m$，逐个考查$B_i$，若$A\in (X-B_i)_F^+$，则以$(X-B_i)$取代$X$

### 模式分解

#### 分解目标

* 无损连接：可以通过自然连接恢复到原来的关系；
* 保持函数依赖：同时也保持了原关系的函数依赖；
* 达到更高级范式：消除了原关系的异常。如分解三达到<BC范式>

#### 模式分解的算法

一般定义： r = {R1<U1 , F1> , R2<U2 , F2>, … , Rn<Un , Fn>}是R<U , F>的一个分解，r是R<U , F>的一个关系。定义mr(r) =  ∏Ri(r) ,若对于R<U , F>的任一个关系r，都有r = mr(r)，则称r是R<U , F>的一个无损连接分解。

#### 无损连接判别

##### 方法一：一个填表的方法

算法：（判别一个分解的无损连接性）

1. 填矩阵$a_i,b_{ij}$
2. 按所有依赖操作对应列，改变元素。如果在某次更改之后，有一行成为a1, a2 , … , an 。则算法终止， $\rho$为无损分解，否则为有损分解
3. 扫描后若无变化，终止；否则返回第二步

举例p65-p73

示例：$U=\{A,B,C,D,E\}, F={AB\rightarrow C, C\rightarrow D,D\rightarrow E},\rho ={(A, B, C), (C, D), (D, E)}$

##### 方法二：无损连接定理

定理：若$U_1 \cap U_2 \rightarrow U_1(or \ U_2)$。若满足，可判断是无损连接

填表法可证明定理（第二行为a1-a3）

|        | $U_1 \cap U_2$ | $U_1 - U_1 \cap U_2$ | $U_2 - U_1 \cap U_2$ |
| ------ | -------------- | -------------------- | -------------------- |
| R1(U1) | $a_1$          | $a_2$                | $b_{13}$             |
| R2(U2) |                | $a_2$                | $a_3$                |

#### 一些分解算法

算法：（达到3NF且保持函数依赖的分解）

1. 对$R<U,F> $中的函数依赖集F进行“极小化处理”（处理后得到的依赖集仍记为F）。
2. 找出不在F中出现的属性，将它们构成一个关系模式，并从U中去掉它们(剩余属性仍记为U)。
3. 若有$X\rightarrow A \in F$，且$XA=U$，则$\rho =\{R\}$，算法终止。
4. 否则，对F按具有相同左部的原则进行分组（设为k组），每一组函数依赖Fi‘所涉及的全部属性为Ui。若Ui  Uj （i≠j） ，就去掉Ui 。由于经过了步骤2，故U =     Ui ，于是 = {R1<U1 , F1> , … , Rk<Uk , Fk>}是R<U , F>的一个保持函数依赖的分解，并且每个Ri<Ui , Fi> 3NF

例子p78

算法：（达到3NF且同时保持无损连接与函数依赖的分解）——见p80

算法：（达到BCNF无损连接分解算法）——见p82

## 第七章 数据库设计

### 数据库设计概述

#### 设计特点

1. 三分技术，七分管理，十二分基础数据
2. 数据库设计与硬件、软件等紧密相关
3. 数据库设计要把结构（数据）设计和行为（处理）设计密切结合起来。

#### 设计方法

手工试凑方法：一堆缺点（p8），仅适合小系统

规范化设计方法

特点

* 分步进行
* 反复性
* 试探性

自动数据库设计工具

#### 基本步骤（6个阶段）

1. 需求分析：调查情况、熟悉业务、预测
2. 概念结构设计
3. 逻辑结构设计
4. 物理结构设计
5. 数据库的实施
6. 数据库运行与维护

### 需求分析

数据字典是系统中各类数据描述的集合，是进行详细的数据收集和数据分析所获得的主要成果

### 概念结构设计

定义：将需求分析得到的用户需求抽象成为信息结构即概念模型的过程

#### 概念结构的特点

1. 能真实、充分地反映现实世界，包括事物和事物之间地联系，能满足用户对数据处理地要求。
2. 易于理解，从而可以用它和不熟悉计算机的用户交换意见。
3. 易于更改，当应用环境和应用要求发生改变时，容易对其进行修改和扩充。
4. 易于向关系、网状、层次等各种数据模型转换

#### 概念结构的设计策略

* 自顶向下：首先定义全局概念结构的框架，然后逐步细化
* 自底向上：首先定义各局部应用的概念结构，然后将它们集成起来，得到全局概念结构。
* 逐步扩张：首先定义最重要的核心概念结构，然后向外扩充，以滚雪球的方式逐步生成其他概念结构，直至总体概念结构
* 混合策略：即将自顶向下和自底向上相结合

### 【补充】数据抽象

摘自：https://blog.csdn.net/scuzoutao/article/details/78005632

数据抽象主要是为了向用户屏蔽复杂性。一共分为三层：

1. 物理层，物理层的数据抽象主要描述了数据在物理层面是怎么存储的数据，这主要是数据库的供应商来研究的。
2. 逻辑层，逻辑层的数据抽象主要描述了数据库中存储着什么数据，这些数据之间有什么关系，这主要是开发人员或者是数据库管理员考虑的，逻辑层的用户不需要去知道我的数据具体是怎么样子存储的。
3. 视图层，在一些数据库系统中，往往数据库是非常庞大的，而我们用户只关心庞大的数据库中的某一个小部分，视图层描述着庞大的数据库中的一部分，作为一个视图，由于大型数据库中的数据非常多而且具有着多样性，这就不可避免的产生了复杂性，视图层的抽象的定义正是为了给只需要访问一部分数据库的用户提供与系统的交互的简单性。
   

视图综合设计方法

局部视图设计

* 确定局部实体
* 确定局部实体之间的联系（包括超类/子类联系）
* 构造局部ER图

局部视图设计的关键在于实体和属性的正确划分。其主要手段为：

* 分类：定义某一概念作为现实世界中一组对象的类型。这些对象具有某些共同的特性和行为。它抽象了对象值和型之间的“is member of”的语义。
* 聚集：定义某一类型的组成成分，它抽象了对象内部类型和成分之间“is part of”的语义。
* 概括

### 逻辑结构设计

#### 局部视图设计

#### 集成ER图

* 合并
  解决各局部ER图之间的冲突，将各局部ER图合并起来生成初步ER图。
* 修改和重构
  消除不必要的冗余，生成基本ER图。

#### 消除各局部ER图的冲突

* 命名冲突
  * 同名异义
    即同一名字在不同的局部ER图中表示不同的概念。

  * 异名同义

    即同一个概念在不同的局部ER图中使用了不同的名字。

* 结构冲突

  结构冲突是模式结构的冲突。它指相同的概念在不同的局部ER图中使用不同的概念结构来表示

* 值域冲突

* 约束冲突

#### 实体间联系的转换

#### 主要步骤

* 形成初始关系数据库模式
* 关系模式规范化
* 关系模式优化
* 定义关系上的完整性和安全性约束
* 子模式定义
* 性能估计

#### 关系模式的优化

优化关系模式的两种方法：

##### 水平分解（减少记录行数）

把经常使用的那一部分数据分解出来作为一个关系，其他数据作为另一个关系

做法：把关系的元组分为若干子集合，定义每个子集合为一个子关系

##### 垂直分解（减少属性数）

经常在一起使用的属性从R中分解出来形成一个子关系模式

做法：把关系模式R的属性分解为若干子集合，形成若干子关系模式

##### 逆规范化

如果经常需要对多个关系进行连接操作，且大多数操作为查询操作，更新很少，则可以考虑将这些关系合并为一个关系

##### 设计子模式

根据局部应用的需求，结合具体DBMS的特点，设计用户外模式

#### 关系存取方法

* 索引存取方法
* 聚簇存取方法
* HASH存取方法

## 第九章（附） 数据库存储（文件结构）

### 存储介质简介

#### 磁盘

简单介绍

#### RAID

* RAID0：即没有容错设计的条带硬盘阵列（Striped Disk Array without Fault Tolerance），以条带形式将RAID组的数据均匀分布在各个硬盘中
* RAID 1 定义：又称镜像（Mirror），数据同时一致写到主硬盘和镜像硬盘
* RAID 2 采用早期的海明码校验组成硬盘阵列
* RAID 3即带有校验的并行数据传输阵列（Paralleled transfer with parity），数据条带化分布在数据盘中，同时使用专用校验硬盘存放校验数据 
* RAID 4是带有共享校验硬盘的独立数据盘
* RAUD 5与RAID 3机制类似，但校验数据均匀分布在各数据硬盘上，RAID成员硬盘上同时保存数据和校验信息
* RAID 6 是带有两个独立分布式奇偶校验方案的独立数据硬盘（Independent data disks with two independent distributed parity schemes）。广义上讲，能够允许两个硬盘同时失效的RAID级别统称为RAID 6

### 缓冲区调度

多数操作系统采用最近未使用(LRU)的缓冲区替换策略

特点：相对于操作系统中的虚拟存储系统,缓冲区管理支持更加复杂的功能

### 数据库文件结构

#### 定长记录

定长记录文件-记录的长度是固定的

简单方法:
记录i 从字节n * (i – 1)开始存储, 其中n 是记录大小.
存在的问题
记录存取简单, 但记录可能跨块，读写需要两个块
变化: 不允许记录跨越块边界

删除方式：自由链表

#### 变长记录

变长记录文件-文件中能够容纳不同长度的、不同类型的记录

### 文件中的记录组织

不同的组织方式

* 堆 – 记录可置于文件中的任何有空间的地方
* 顺序 – 记录按顺序存储, 基于每条记录在搜索码上的值
* 散列 – 对记录的某属性计算散列函数; 计算结果决定该记录应该置于文件的哪个块中

#### 顺序文件组织 

维护记录的物理顺序代价高

* 删除 – 利用指针链
* 插入 – 确定待插入记录的位置
  若有自由空间则在该处插入
  若无自由空间, 插入到溢出块
  两种情况都要更新指针链
  如果溢出块中数据很多，则逻辑顺序和物理顺序存在很大的不同，可能导致数据访问中I/O操作过多
* **需要不时重组文件以恢复物理存储顺序，重组代价高**

#### 聚簇文件组织

* 简单的文件结构将每个关系存储在一个单独的文件中
* 利用聚簇文件组织可以将多个关系存储在一个文件中

#### 关系数据库的文件选择

* 存储关系到一个文件
  * Advantage
    充分利用OS所提供的功能，减少DMBS的处理代价
  * Disadvantage
    DBMS的某些优化策略不支持
* 存储多个关系到一个文件（多采用）
  * Advantage
    DBMS支持某些优化策略，可以在文件中设计复杂的结构
  * Disadvantage
    增加了数据库的大小和复杂性

#### 数据字典的存储

数据字典(也称为系统目录) 保存元数据: 即关于数据的数据

## 第十章（附） 索引

索引评价度量

### 索引分类

有序索引：稠密索引文件

有序索引：稀疏索引文件

#### 多级索引

为减少对索引记录的磁盘存取次数, 将主索引视为存储在磁盘上的顺序文件并为它建立一个稀疏索引.
外索引 – 主索引的稀疏索引
内索引 – 主索引文件
如果外索引仍太大而不能放入内存, 还可再为它创建另一层索引, 如此类推

* 辅助索引
* B+-树索引文件
* 插入、删除
* Hash数据索引

## 第九章 查询优化

### 查询处理

#### 查询处理步骤

* **关系数据库管理系统查询处理可以分为4个阶段：查询分析、查询检查、查询优化和查询执行**

1. 查询分析

   首先对查询语句进行扫描、词法分析和语法分析。从查询语句中识别出语言符号,如SQL关键字、属性名和关系名等,进行语法检查和语法分析,即判断查询语句是否符合SQL语法规则。如果没有语法错误就转入下步处理,否则便报告语句中出现的语法错误。

2. 查询检查

   对合法的查询语句进行语义检查,即根据数据字典中有关的模式定义检查语句中的数据库对象,如关系名、属性名是否存在和有效。如果是对视图的操作,则要用视图消解方法把对视图的操作转换成对基本表的操作。还要根据数据字典中的用户权限和完整性约束定义对用户的存取权限进行检查。如果该用户没有相应的访问权限或违反了完整性约束,就拒绝执行该查询。当然,这时的完整性检查是初步的、静态的检查。检查通过后便把sQL查询语句转换成内部表示,即等价的关系代数表达式。这个过程中要把数据库对象的外部名称转换为内部表示。关系数据库管理系统一般都用查询树(query tree),也称为语法分析树(syntax tree)来表示扩展的关系代数表达式。

3. 查询优化

   每个查询都会有许多可供选择的执行策略和操作算法,查询优化就是选择一个高效执行的查询处理策略。查询优化有多种方法。按照优化的层次一般可将查询优化分为代数优化和物理优化。代数优化是指关系代数表达式的优化,即按照一定的规则,通过对关系代数表达式进行等价变换,改变代数表达式中操作的次序和组合,使查询执行更高效;物理优化则是指存取路径和底层操作算法的选择。选择的依据可以是基于规则(rule based)的,也可以是基于代价(cost based)的,还可以是基于语义(semantic based)的。实际关系数据库管理系统中的查询优化器都综合运用了这些优化技术,以获得最好的查询优化效果。

4. 查询执行

   依据优化器得到的执行策略生成查询执行计划,由代码生成器(code generator)生成执行这个查询计划的代码,然后加以执行,回送查询结果。

#### 查询处理的基本步骤2（ppt版）

* 语法分析与翻译
* 优化
* 执行查询语句

### 查询优化

#### 查询优化的步骤

* 将查询转换成某种内部表示，通常是语法树。
* 根据一定的变换规则，把语法树转换为优化形式。
* 选择低层的操作算法。
* 生成查询执行计划（也称查询执行方案，是由一系列内部操作构成的）。

#### 查询优化的分类

按照优化的层次一般可将查询优化分为代数优化和物理优化。

* **代数优化**是指关系代数表达式的优化,即按照一定的规则,通过对关系代数表达式进行等价变换,改变代数表达式中操作的次序和组合,使查询执行更高效；
* **物理优化**则是指存取路径和底层操作算法的选择。选择的依据可以是基于规则(rule based)的,也可以是基于代价(cost based)的,还可以是基于语义(semantic based)的。
* 实际关系数据库管理系统中的查询优化器都综合运用了这些优化技术,以获得最好的查询优化效果

#### 查询和连接优化算法

##### 选取运算的实现算法

* 全表扫描方法
* 折半扫描
* 索引扫描

##### 连接操作的实现算法

* 嵌套循环方法
* 排序-合并方法
* 索引连接方法
* HASH join方法

#### 查询代价的度量

查询代价：查询处理对各种资源的使用情况

* 总代价=I/O代价+CPU代价+通信开销

* 一个重要的影响因素：主存中缓冲区的大小M。（如多次运行同一算法，开始极慢，之后由于数据读入缓存，执行时飞一般的速度）

### 查询优化例子

例：求选修了课程C2的学生姓名
SELECT Student.Sname
FROM Student, SC
WHERE Student.Sno=SC.Sno
AND SC.Cno='2';

假设:

* Student表中有1000条学生记录:$n_{student}$= 1000
* SC表中有10000条选课记录: $n_{sc}$= 10000
* 其中选修2号课程的选课记录为50条: SC(cno,SC)=50
* 一个块可以装10个Student元组或100个SC元组：$f_{student}$= 10，$f_{sc}$= 100
* Student表占用的块: $b_{student}$= 100
* SC表占用的块:$b_{sc}$= 100
* 一个块可以装10个Student和SC的连接结果元组：$f_{join}$= 10
* 缓冲: 内存中一次可以存放5块Student元组、1块SC元组和若干块连接结果元组
* 读写速度：20块/秒

#### 查询1

$$
Q_1=\prod_{Sname}(\sigma_{Student.Sno=SC.Sno}\and SC.Cno='2'(Student\times SC))
$$

1、$(Student\times SC)$块嵌套循环

* 读数据时间105s

* 中间结果大小=$10^3*10^4=10^7$（1000万条元组）
* 写中间结果时间：$5*10^4s$

总时间：$105+5*10^4+5*10^4=27.8h$

#### 查询2

$$
Q_2=\prod_{Sname}(\sigma_{SC.Cno='2'}(Student\bowtie SC))
$$

* 读数据时间105s

* 中间结果大小=$10^4$（减少1000倍）
* 写中间结果时间：$50s$

总时间：$105+50+50=205s$

#### 查询3

$$
Q3 = \prod_{Sname}(S \bowtie SC.Cno='2'(SC))
$$



* 读SC表总块数$=b_{sc}=100$块
* 读数据时间=SC(Cno,SC)/20=100/20=5秒
* 中间结果大小=50条 不必写入外存
* 读S表总块数= 1000/10-100块
* 读数据时间=100/20=5秒
* 总时间=5+5秒=10秒

两个表达式等价：产生的结果关系具有相同的属性集和相同的元组集。



关系代数等价变换规则

1-2: 连接、笛卡尔积的交换律、结合律
3： 合并或分解投影运算
4： 合并或分解选择运算
5-8：选择运算与其他运算交换
5，9，10： 投影运算与其他运算交换



查询优化的一般准则

* 选择运算应尽可能先做。目的：减小中间关系。
  在执行连接操作前对文件适当进行预处理
  排序
  在连接属性上建立索引
  投影运算和选择运算同时做。目的：避免重复扫描关系。
  把投影运算与其前面或后面的双目运算结合起来。目的：减少扫描关系的遍数。



查询树



### 性能优化

对数据库性能影响最大的是数据库的设计和开发。通常，所谓的性能优化实际上就是重新开发数据库系统中设计的很糟的那一部分。 

优化准则

 花费尽可能多的努力来设计数据库模式，所有的优化都要基于数据库模式。
 集中精力优化运行最频繁的代码，而不是那些运行最慢的代码。
 在升级硬件之前进行优化。即使在速度快的服务器上，坏代码仍旧是坏代码。

等等等等

负载测试

数据负载测试
只有当数据量超出了服务器内存容量好几倍的时候，才能够对数据库模式和查询进行负载测试。 
用户负载测试

只有当使用大量的用户来测试数据库时才有可能发生锁争用，而锁争用会导致严重的性能问题。

清除测试的影响
数据库已经经过优化，它可以智能地将数据缓存在内存中，而这将会影响到后续测试的结果。因此，测试前要刷新内存，这可以通过停止并重新启动服务器实现。

数据库设计与性能

## 第十章 数据库恢复技术

### 事务

#### 事务定义

事务是用户定义的一个数据库操作序列构成，这些操作要么全做，要么全不做，是一个不可分割的工作单位

* 事务与应用程序是两个概念，一般来说，一个应用程序可以包含多个事务。
* 事务的开始与结束可以由用户显式控制。如果用户没有显式定义事务，则由DBMS按缺省规定自动划分事务。

#### SQL中事务

* 事务以Begin transaction开始，以Commit work或 Rollback work结束。
* Commit work表示提交，事务正常结束。
* Rollback work表示事务非正常结束，撤消事务已做的操作，回滚到事务开始时状态。

#### 事务的特性（ACID）

* 原子性(Atomicity)
  	 事务是数据库的逻辑工作单位，事务中包括的诸操作要么全做，要么全不做。
* 一致性(Consistency)
  	事务执行的结果应当使数据库从一个一致性状态转变为另一个一致性状态。
* 隔离性(Isolation)
  	一个事务的执行不能被其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能相互干扰。
* 持久性(Durability)
  	一个事务一旦提交之后，它对数据库的影响必须是永久的。事务提交后，系统发生故障不能改变事务的持久性。

#### 故障的种类

* 系统故障
  系统故障是指造成系统停止运行的任何事情，使得系统要重新启动。如硬件错误，操作系统故障，停电等。
* 介质故障
  介质故障指外存故障，如磁盘损坏，瞬时强磁场干扰等。这类故障将破坏全部或部分数据库，并影响正在存取这部分数据的所有事务。
* 计算机病毒

### 恢复的实现技术

数据库恢复的基本原理为冗余。如果数据库中任何一部分数据被破坏或处于不正确的状态，则可以通过存储在系统别处的冗余数据来重建。

建立冗余的常用方法

#### 数据转储

* 静态转储
  静态转储是在系统中无事务运行时进行的转储操作。即转储开始时数据库处于一致状态，转储过程中，不允许对数据库的任何存取、更新活动

* 动态转储
  动态转储是指转储期间允许对数据库进行存取或修改，即转储和用户事务可以并发执行。动态转储克服了静态转储的缺点，但除了转储数据库的数据以外，还必须把转储期间各事务对数据库的修改记录下来，这样才能保证把数据库恢复到某一时刻的一致状态。

转储的方式

* 海量转储
  海量转储指每次转储全部数据库。
* 增量转储
  增量转储指每次只转储上一次转储后更新过的数据。

#### 登录日志文件

日志文件是用来记录事务对数据库的更新操作的文件。日志文件主要有两种格式：以记录为单位的日志文件和以数据块为单位的日志文件。

对于以数据块为单位的日志文件，日志记录的内容包括事务标识以及**更新**前和更新后的数据块。

日志文件的作用
日志文件可以用来进行事务故障恢复和系统故障恢复，并协助后备副本进行介质恢复。其具体作用是：

* 事务故障和系统故障恢复必须使用日志文件。
* 在动态转储方式中必须建立日志文件，后备副本和日志文件综合起来才能保证备份的一致性，和有效地恢复数据库。
* 在静态转储方式中，也可以建立日志文件。当数据库发生故障时，用后援副本把数据库恢复到转储结束时的正确状态，然后利用日志文件重做已完成的事务，把数据库恢复到故障前的正确状态。

为保证数据库是可恢复的，登记日志文件时必须遵循两条原则：
登记的次序严格按并发事务执行的时间顺序。
必须先写日志文件，后写数据库。

#### 恢复策略

事务、系统仅需日志，介质再需转储（提供期间的操作）

##### 事务故障的恢复

事务故障是指事务在运行至正常终止点之前被终止。事务故障的恢复是由系统自动完成的。具体步骤：

* 反向扫描文件日志（即从最后向前扫描日志文件），查找该事务的更新操作。
* 对该事务的更新操作执行逆操作，即将日志记录中的“更新前的值”写入数据库。这时，如果记录中是插入操作，则相当于做删除操作；如果记录中是删除操作，则相当于做插入操作；如果记录中是修改操作，则用修改前的值代替修改后的值。
* 继续反向扫描日志文件，查找该事务的更新操作，并做同样处理
* 如此处理下去，直到读到该事务的开始标志。

##### 系统故障的恢复

系统故障造成数据库不一致状态的原因有两个，一是未完成的事务对数据库的更新可能已经写入数据库；二是已提交事务对数据库的更新可能还留在缓冲区还没来得及写入数据库。因此恢复操作就是要撤销故障发生时未完成的事务，重做已完成的事务。

##### 介质故障的恢复

介质故障将全部或部分地破坏数据库甚至是日志文件，其恢复的方法是：
装入最新的数据库后备副本（离故障发生时刻最近的转储副本），使数据库恢复到最近一次转储时的一致状态。对于动态转储的副本，还需要装入转储开始时刻的日志文件副本，将数据库恢复到一致状态。
装入转储以后的日志文件副本，重做已经完成的事务。



#### 推迟更新技术：所有日志记录完才更改数据库

#### 即时更新技术：每执行1aql语句更新数据库

#### 具有检查点的恢复技术

这种技术在日志文件中增加一类新的记录－检查点（checkpoint）记录，增加一个重新开始文件，并让恢复子系统在登录日志文件期间动态地维护日志。

数据库镜像

## 第十一章 并发控制

优点
一个事务由不同的步骤组成，所涉及的系统资源也不同。这些步骤可以并发执行，以提高系统的吞吐量，改善系统的资源的利用率。
系统中存在着周期不等的各种事务，串行会导致难以预测的时延。采用并发会减少平均响应时间，特别是改善短事务的响应时间。

### 并发执行的问题

丢失修改：两个事务T1和T2读入同一数据并修改， T2提交的结果破坏了T1提交的结果，导致T1的修改被丢失。

不可重复读：事务T1读取某一数据后，事务T2对其做了修改，当事务T1再次读取该数据时，得到与前一次不同的值。

不可重复读之幻影行：事务T2删除或插入一些记录

脏数据：读“脏”数据(Dirty Read) 是指事务T1修改某一数据，并将其写回磁盘，事务T2读取同一数据后，T1由于某种原因被撤销，这时T1已修改过的数据恢复为原值，T2读到的数据就与数据库中的不一致，则T2读到的数据就为“脏”数据。

需要进行并发控制的原因：
如果不进行并发控制，当多个事务并发执行的时候，有可能会相互影响，从而读取或者存储不正确的数据，破坏数据库的一致性。

总结，造成并发执行事务问题的原因是：
多个事务同时存取同一个数据集合，
并且其中至少有一个事务对该数据集合进行了更新操作

解决问题的思路
避免不同事务同时对同一数据进行可能导致数据不一致的操作。
采用的技术—封锁（Locking）
封锁就是事务T在对某个数据对象如表、记录等操作之前，先向系统发出请求，对其加锁，从而对该数据对象有了一定的控制，在事务T释放它的锁之前，其他事务不能更新此数据对象。

封锁的类型

* 排它锁（X锁，eXclusive lock）：事务T对数据对象A加上X锁，则只允许T读取和修改A，其它事务对A的任何封锁请求都不能成功（因而不能读取和修改R），直至T释放A上的X锁。
* 共享锁（S锁，Share lock）：事务T对数据对象A加上S锁，则事务T可以读取但不能修改A，其它事务只能对A加S锁（因而可以读取A），而不能对A的加X锁（因而不能修改A），直到T释放A上的S锁。

封锁协议

一级封锁协议
事务T在修改数据R之前必须对其加X锁，直到事务结束才释放。事务结束包括正常结束(COMMIT)和非正常结束(ROLLBACK)。
一级封锁协议可以防止丢失修改，并保证事务T是可恢复的。在一级封锁协议中，如果仅仅是读数据而不对其进行修改，是不需要对其加锁的，因此它不能保证可重复读和不读“脏”数据。

二级锁协议
二级锁协议是：一级锁协议加上事务T在读取数据R之前必须先对其加S锁，读完后即可释放S锁。
二级锁除了防止丢失修改，还可以进一步防止读“脏”数据。但由于读完后即可释放S锁，所以不能保证可重复读。

三级锁协议
三级锁协议是：一级锁协议加上事务T在读取R之前必须对其加S锁，直到事务结束才释放。三级封锁协议除了防止丢失修改和读“脏”数据以外，还进一步防止了不可重复读。

### 死锁与活锁

预防死锁
一次封锁法
一次封锁法要求每个事务必须一次将其所有要使用的数据全部加锁，否则就不能执行。
一次加锁法可以有效地防止死锁的发生，但由于需要扩大加锁的范围，因此降低了系统的并发度。
顺序封锁法

死锁检测
超时法
如果一个事务的等待时间超过了规定的期限，就认为发生了死锁。
等待图法

死锁恢复
DBMS的并发控制子系统一旦检测到系统中存在死锁，就要设法解除。通常采用的方法是选择一个处理死锁代价最小的事务，将其撤销，释放此事务持有的所有锁，使其他事务得以继续运行下去。对于所撤销的事务所作的操作必须加以恢复。

一般选执行时间最短的（最常用）；或持有资源最少

可串行性调度

定义：多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行的执行它们时的结果相同，我们称这种调度策略为可串行化调度。一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度。

举例

事务T1:
读B;
A=B+1;
写回A

事务T2:
读A;
B=A+1;
写回B;

#### 两段锁协议

Two-phase Locking

①在对任何数据进行读、写操作之前，事务首先要获得对该数据的封锁。
②在释放一个封锁之后，事务不再获得任何其它封锁。

定理：若所有事务均遵从两段锁协议，则这些事务的所有并行调度都是可串行化的

* 不符合两端锁协议也可能”可串行性调度“，充分条件。如p50不符合，但没问题
* 符合两端锁协议也可能死锁，如p52页的情况

### 多粒度封锁

* 核心思想是灵活调整粒度，如一些内容可以开放给其他进程使用，班级、同学等数据范围

封锁粒度 封锁对象的大小称为封锁粒度
封锁对象：包括逻辑单元，如:属性值、属性值集合、元组、关系、某索引项、整个索引、整个数据库；和物理单元如：物理页、块。
封锁粒度大，则并发度低，封锁机构简单，开销小。
	封锁粒度小，则并发度高，封锁机构复杂，开销高。
如果在一个系统中同时支持多种封锁粒度供不同的事务选择是比较理想的，这种封锁方法称为多粒度封锁（Multiple Granularity Locking）。选择封锁粒度时应同时考虑封锁开销和并发度两个因素，适当选择封锁粒度以达到最优效果。

多粒度树
多粒度树的根结点是整个数据库，表示最大的粒度。叶结点表示最小的粒度。

#### 意向锁

意向锁的含义是如果对一个结点加意向锁，则说明该结点的下层结点正在被加锁；对任一结点加锁时，必须先对它的上层结点加意向锁。

一般的，对某个数据对象加锁，系统要检查该数据对象上有无显式封锁与之冲突；还要检查其所有上级结点，看本事务的显式封锁是否与该数据对象上的隐式封锁冲突；还要检查其所有下级结点，看上面的显式封锁是否与本事务的隐式封锁冲突。效率很低，因此引入了意向锁。

三种常用的意向锁

* 意向共享锁（Intent Share Lock，简称IS锁）
  如果要对一个数据对象加IS锁，表示它的后裔结点拟（意向）加S锁。
* 意向排它锁（Intent Exclusive Lock ，简称IX锁）
  如果要对一个数据对象加IX锁，表示它的后裔结点拟（意向）加X锁。
* 意向共享排它锁（ Share Intent Exclusive Lock ，简称SIX锁）
  如果要对一个数据对象加SIX锁，表示对它加S锁，再加IX锁，即SIX=S+IX。

注

* 由于意向锁IS、IX、SIX表示后裔节点，因此同一节点可同时加IS、IX
  锁并不冲突，因为可表示的为一个子结点IS、另一个IX

* SIX例子 58分？

## 第十四章 分布式数据库

定义
分布式数据库是由一组数据组成的，这组数据分布在计算机网络的不同计算机上，网络中每个结点具有独立处理的能力（称为场地自治），可以执行局部应用（只对本结点数据进行存取的应用），同时每个结点也能通过网络通讯支持全局应用（指存取两个或两个以上的结点的数据库应用）。
	分布式数据库强调场地自治性（局部应用）以及自治场地之间的协作性（全局应用）。



分布式数据库具有以下两个特点：

* 分布性
  分布性有两层含义，一是指数据库中的数据不是都存储在同一结点（更确切的讲，不存储在同一计算机的存储设备上），而是分布在多个结点上；二是指各结点具有独立的数据库处理能力，能够有效地支持局部应用。
* 逻辑整体性
  分布在各结点的数据不是孤立的，而是相互联系的，是一个逻辑整体，能够支持存取多个结点数据的全局应用。

分布式数据库系统特点

数据独立性

集中与自治相结合的控制机构

适当增加数据冗余

全局的一致性、可串行性和可恢复性

#### 目标

* 适应部门分布的组织结构，降低费用
* 提高系统的可靠性和可用性
* 充分利用数据库资源，提高现有集中式数据库的利用率
* 逐步扩展处理能力和系统规模

#### 分布式数据库的体系结构

全局外模式
	全局应用的用户视图，是全局概念模式的子集。
全局概念模式
	定义分布式数据库中数据的整体逻辑结构，使得数据如同没有分布一样。
分片模式
	每一个全局关系可以分为若干互不相交的部分，每一部分称为一个片段。分片模式定义片段以及全局关系到片段的映像。
分布模式
	定义片段的存放结点。

#### 分布（网络）透明性

分片透明性
	用户或应用程序只对全局关系进行操作而不必考虑关系的分片。如果分片模式改变了，通过调整全局模式与分片模式之间的映象关系来保持全局模式不变。
位置透明性
	用户或应用程序不必了解片段的存储位置。
局部数据模型透明性
	用户或应用程序不必了解局部场地上使用的是哪种数据模型。

* 分布独立性 select * From S
* 不具有分片透明性：Select * From S_A
* 不具有位置透明性：Select * From S_B@Site2

（示例：设有全局关系S，它被划分为两个片段S-A（本科生），S-B（研究生），S-B有两个副本。见p14）

### 数据在分布式数据库中的存储途径

#### 重复存储

#### 分片存储

分片时必须遵循以下原则：
完全性：被划分关系中的每个元组必须属于一个片段。
不相交性：同一个关系的片段互不相交。
可重构性：如果R被划分为片段R1、R2、、Rn，则R能从R1、R2、、Rn恢复出来。

#### 分片方式

##### 水平分片

将关系r依照一定条件按行分为不相交的若干子集$r_1,r_2,...,r_n$，每个子集$r_i$称为一个水平片段。
一个水平片段可以看成是关系上的一个选择：
$$
r_j = \sigma_{P(i)}(r)
$$
关系的重构可以通过并运算来实现
$$
r = r_1 \cup r_2...\cup r_n
$$

##### 垂直分片

将关系r按列分为若干属性子集$r_1,r_2,...,r_n$，每个子集$r_i$称为一个垂直片段。

关系的重构可以通过连接运算来实现
$$
r = r_1 \bowtie r_2...\bowtie r_n
$$
**所有分片都包括关系的码**

##### 导出分片

* 导出水平分片，分片的条件不是关系本身属性条件，而是其它关系的属性条件。
* 如SC（SNO，CNO，G）按学生系别分片。

##### 混合分片

* 关系按某种方式分片后，得到的片段再按另一种方式继续分片。
* 如SC（SNO，CNO，G）按学生系别分片，再对每个片段按成绩（及格，不及格）分片。

#### 组合存储

​	这种方法是重复存储和分片存储相结合的方法。关系被划分为几个片段，系统为每个片段维护几个副本，每个副本存放于不同的结点上。

### 分布式数据库设计

#### 命名和局部自治性

每个数据项（关系、副本、片段）必须有唯一的名字，在分布式数据库系统中必须保证在不同的结点上不会用同一个名字来代表不同的数据项。

（如重复的”刘洋“名字）

途径1：名字服务器

* 所有名字都在名字服务器中注册，每个名字对应一个数据项。（判定名字是否唯一）
* 缺陷：名字服务器成为名字解析的瓶颈；其故障将影响整个系统的运行；局部自治性降低。

途径2：将结点标识作为前缀加到该结点数据项的名字前面。使用这一方法，能够保证名字的唯一性，不须中央控制，局部自治性提高；但不能保证**网络透明性**。（破坏了分布透明性）



D-DBMS由四个部分组成：

* LDBMS，局部场地上的DBMS，主要功能是建立和管理局部数据库，提供场地自治能力，执行局部应用以及全局查询的子查询。
* GDBMS，全局数据库管理系统，主要功能是提供分布透明性，协调全局事务的执行，协调各局部DBMS以完成全局应用，保证数据库的全局一致性，执行并发控制，实现更新同步，提供全局恢复等功能。
* 全局数据字典，存放全局概念模式、分片模式、分布模式等的定义，以及各模式之间的映像定义，存放有关用户存取权限的定义、完整性约束的定义等。
* 通信管理，在分布式数据库各场地之间传送消息和数据，完成通信功能。



D-DBMS的分类





分布式查询处理的过程包括：

* 查询变换
     将用户查询转换为析取范式或合取范式，并进行语义分析，检查查询的正确性等工作。
* 数据定位
      数据定位的目的是把用户定义在全局概念模式上的查询转换为定义在局部概念模式上的查询。
* 全局查询优化，全局查询优化时需要选择执行操作的顺序，降低网络通信的开销。
* 局部查询优化
     局部查询优化的目的是为每个局部查询选择优化的执行计划，其方法与集中式数据库的查询优化策略和方法相同。



传送时间T=总传输延迟+总数据量/传输速度

1.把关系P从B站传送到A站，在A站进行查询

  2.把关系S，SP从A站传送到B站，在B站进行查询

⒊在A站连接S与SP，选出城市为北京的元组（假定有105个），然后对其中每个元组的P#，询问B站，看其是否为红色。
	传送时间T=2  105s

⒋在B站选出红色零件（假定有10个），然后对每个元组询问A站，看北京的供应商是否供应此零件。
	传送时间T=2  10=20s

5.在A站选出北京的供应商（105个），传送到B站，在B站完成查询。
	传送时间T=1+ 105100/104=103s

⒍在B站选出红色零件（10个），把结果传送到A站，在A站完成查询。
	传送时间T=1+ 10100/104=1.1s



半连接运算
定义：半连接R    S=$\prod_R$（$R\bowtie S$）

半连接作用
	找出R中能够与S中元组相连接的元组来，类似于在连接之前先做选择和投影。
R   S = （R    S）  S
R   S = （S    R）  R
半连接的非对称性
R   S  S    R



通讯代价模型
TC（X）= C0+X*C1
其中X为数据传输量。
C0为两结点初始化一次传输所花费的开销。
C1为传输率，即单位数据传输所花费的时间。
采用半连接的通讯代价：
CSJ=2C0+(size(R')*card(R')+size(S)*card(S'))*C1
	不采用半连接的通讯代价：
CJN=C0+size(S)*card(S) *C1
当S中参与连接的元组足够少时采用半连接策略是有利的。



分布式事务处理

事务管理器TM：管理那些访问存储在一个局部结点中的数据的事务。事务可以是局部事务，也可以是全局事务的一部分。
事务协调器TC：协调该结点上发起的各事务（局部的或全局的）的执行。

事务管理器功能
维护一个用于恢复的日志。
参与适当的并发控制模式，以协调在该结点上执行的事务的并发执行。
事务协调器功能
启动事务的执行。
将事务分解为若干子事务，并将子事务分派到适当的结点上去执行。
协调事务的终止，保证事务在所有的结点上都提交或都中止。
一个全局事务的各个子事务要么全部执行，要么全部中止。



事务两阶段提交协议
	假定事务T在结点Si发起

阶段1：

* 事务协调器TCi向日志中加入一条记录<prepare T>，并强制该日志写入稳定存储器中。
* TCi将消息<prepare T>发送到执行T的所有结点上。
* 当某结点接受到上述消息时，该结点的TM回答确定是否提交T中属于它的那部分，若否，则TM将记录<no T>加入到日志中，并向TCi发送消息<abort T>。若是，则TM将记录<ready T>加入到日志中，并将日志强制写入稳定存储器中，并向TCi发送消息<ready T>。

阶段2：

* 当TCi收到所有结点对<prepare T>消息的回答时，或等待响应的时间已过，TCi决定事务T是提交还是中止。
* 如果TCi 收到的都是<ready T>消息，事务就可以提交，否则事务必须被中止。根据结果的不同向日志中写入<commit T> 或者<abort T>，并强制将日志写入稳定存储器中。
*  向所有参与的结点发送消息<commit T>或<abort T>。
* 结点收到此消息后，就把该消息记入日志中。（向TCi发送消息<acknowledge T>； TCi收到该消息后，将记录<complete T>加入到日志中）。

分布式并发控制

分布式锁技术
若分布式数据库中**没有重复存储的数据**（一份数据仅一份来管理），可以采用如下的分布式锁技术：每个结点保留一个局部锁管理器，处理对存储在本地的数据加锁和释放锁的请求。当事务T希望对结点Si上的数据项Q加锁时，T简单的向结点上的锁管理器发出一个加锁请求。分布式锁技术具有实现简单的特点，它处理一个加锁请求需要两次通信，处理释放锁请求需要一次通信。但其死锁处理较为复杂。

集中式锁技术
集中式锁技术仅有一个锁管理器，这个锁管理器位于唯一一个结点（如Si）上。所有的加锁和释放锁的请求都在该结点上处理。集中式锁技术具有以下优点：
实现简单 加锁请求需要两次通信，释放锁请求需要一次通信。
死锁处理简单 可按照集中式数据库的方法进行处理
集中式锁技术具有以下缺点：
瓶颈问题 Si是一个锁管理瓶颈
脆弱性 如果Si出现故障，系统无法正常运行。

混合锁技术
混合锁技术是集中式和分布式锁技术的折中。这种技术设置多个锁管理器，每个锁管理器管理一组数据的加锁和释放锁的请求。每个锁管理器位于不同的结点上。
