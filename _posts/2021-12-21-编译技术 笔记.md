## 第01讲 概论

### 1.1 基本概念

#### 源程序

定义：用汇编语言或高级语言编写的程序称为源程序。

#### 目标程序

定义：用**目标语言**所表示的程序。
目标语言：可以是介于源语言和机器语言之间的“中间语言”，可以是某种机器的机器语言,也可以是某机器的汇编语言。

#### 翻译程序

定义：将**源程序**转换为**目标程序**的程序称为翻译程序。它是指各种语言的翻译器，包括汇编程序和编译程序，是汇编程序、编译程序以及各种变换程序的总称。

#### 汇编程序/编译程序

* 汇编程序：若源程序用汇编语言书写，经过翻译程序得到用机器语言表示的程序，这时的翻译程序就称之为汇编程序，这种翻译过程称为“汇编”(Assemble）
* 若源程序是用高级语言书写，经加工后得到目标程序，这种翻译过程称“编译”（Compile)
* 【注】汇编程序与编译程序都是翻译程序，主要区别是加工对象的不同。

#### 解释程序

（Interpreter）

对源程序进行解释执行的程序。（Input：输入数据；Output：输出数据/错误信息）

### 编译过程

* 定义：编译过程是指将**高级语言程序**翻译为等价的**目标程序**的过程。
* 习惯上是将编译过程划分为5个基本阶段：
  1. 词法分析；
  2. 语法分析；
  3. 语义分析、生成中间代码；
  4. 代码优化；
  5. 生成目标程序；

#### 词法分析

任务：分析和识别单词。

> 单词：是语言的基本语法单位，一般语言有四大类单词
> <1>语言定义的关键字或保留字（如BEGIN、END、IF）
> <2>标识符
> <3>常数
> <4>分界符（运算符） （如+、-、*、/、;、（、） ……）

#### 语法分析

任务：根据语法规则（即语言的文法），分析并识别出各种语法成分，如表达式、各种说明、各种语句、过程、函数等，并进行语法正确性检查。

#### 语义分析、生成中间代码

任务：对识别出的各种语法成分进行语义分析，并产生相应的中间代码。

> * 中间代码：一种介于源语言和目标语言之间的中间语言形式
> * 生成中间代码的目的：
>   <1> 便于做优化处理；
>   <2> 便于编译程序的移植。
>
> * 中间代码的形式：编译程序设计者可以自己设计，常用的有
>   四元式、三元式、逆波兰表示等。

#### 代码优化

任务：目的是为了得到高质量的目标程序。

#### 生成目标程序

由中间代码很容易生成目标程序（地址指令序列）。这部分工作与机器关系密切 ，所以要根据机器进行。在做这部分工作时（要注意充分利用累加器），也可以进行优化处理。

### 1.4 编译程序的构造

#### 阶段划分

* 编译过程划分为五个基本阶段，与此相对应，我们将实现整个编译过程的编译程序划分为五个逻辑阶段：

1. 词法分析程序；
2. 语法分析程序；
3. 语义分析生成中间代码；
4. 代码优化程序；
5. 生成目标程序；

* 在上列五个阶段中都要做两件事：

1. 建表和查表；
2. 出错处理；

#### 遍（PASS）

* 定义：对源程序（包括源程序中间形式）从头到尾扫描一次，并做有关的加工处理 ，生成新的源程序中间形式或目标程序，通常称之为一遍。
* 一遍扫描即可完成整个编译工作的称为**一遍扫描编译程序**。

> 【One-例题】
>
> 编译程序分成若干个“遍”是为了（）。
> 	==A. 使编译程序的结构更加清晰==
> 	B. 提高编译程序的执行效率
> 	C. 利用有限的内存，提高目标程序的执行效率
> 	D. 由于有限的内存，降低编译程序的执行效率

#### 前端和后端

根据编译程序各部分功能，将编译程序分成**前端**和**后端**。

##### 前端

* 定义：通常将与源程序有关的编译部分称为前端。
* 包含：词法分析、语法分析、语义分析、中间代码生成、代码优化-------分析部分
* 特点：与**源语言**有关

##### 后端

* 定义：与目标机有关的部分称为后端。
* 包含部分：目标程序生成（与目标机有关的优化）-------综合部分
* 特点：与**目标机**有关

### 1.5 编译技术的应用

翻译：– 支持高层的编程抽象；– 支持底层的硬件体系结构

优化：– 从高层抽象翻译到底层过程中引入冗余；– 优化就是消除冗余的过程；– 更快的执行速度；– 更小的空间

程序分析：– 安全性、功能正确、…

略。。

## 第02-04讲 文法和语言

### 2.1 预备知识

字母表、符号、符号串、空符号串等概念

### 2.2 文法的非形式讨论

文法：文法是对语言结构的定义与描述。即从形式上用于描述和规定语言结构的称为“文法”（或称为“语法”）

语法规则：我们通过建立一组规则，来描述句子的语法结构。规定用“::=”表示“由...组成”（或“定义为...”）。

由规则推导句子：有了一组规则之后，可以按照一定的方式用它们去推导或产生句子。
推导方法：从一个**要识别的符号**开始推导，即用相应规则的**右部**来替代规则的左部，每次仅用一条规则去进行推导。

> 说明：
> (1) 有若干语法成分同时存在时，我们总是从最左的语法成分进行推导，这称之为最左推导，类似的有最右推导(还有一般推导）。
> (2) 从一组语法规则可推出不同的句子，如以上规则还可推出“大象吃象”、“大花生吃象”、“大花生吃花生”等句子，它们 在语法上都正确，但在语义上都不正确。

### 2.3 文法和语言的形式定义

#### 文法的定义

【定义1】 文法G=（Vn，Vt，P，Z）

* $V_n$：非终结符号集
* $V_t$：终结符号集
* P：产生式或规则的集合
* Z：开始符号（识别符号）, $Z\in V_n$

> 规则的定义：
> 规则是一个有序对(U, x), 通常写为:
> $U ::= x$ 或$U \rightarrow x$ ，$| U| = 1 \ |x| \geq 0$

几点说明：

* 产生式左边符号构成集合Vn，且 Z ∈Vn

* 有些产生式具有相同的左部，可以合在一起。例：

  <数字串> → <数字串> <数字> | <数字>
  <数字> →0 | 1 | 2 | 3 | …… | 9

* 给定一个文法，需给出产生式（规则）集合，并指定识别符号

#### 推导的形式定义

【定义2.6 直接推导】书p31

【定义2.7 间接推导】书p32

ppt 02讲-p28（另一种版本）

* 分为最左推导、最右推导（规范推导）几类

#### 语言的形式定义

几个蛮重要的定义

【定义2.8 语言】设$G[Z]$是定义在字汇表V上的一个文法（Z是识别符号，在此省去了尖括号）：

##### 句型

x是（文法G的）句型（等价于）$\iff$：
$$
Z\stackrel{*}\Rightarrow x , 且 x\in V^*
$$

##### 句子

x是（文法G的）句型（等价于）$\iff$：
$$
Z\stackrel{+}\Rightarrow x , 且 x\in V_t^*
$$

句子是终结符号组成的符号串

##### 语言

* 文法$G[Z]$产生的所有句子的集合，记为$L(G[Z])$，称为文法$G[Z]$所定义的语言：

$$
L(G[Z])=\{x | x∈V_t^*, Z\stackrel{+}\Rightarrow x \}
$$

#### 递归文法

优点：可用有穷条规则，定义无穷语言

左递归文法的缺点：不能用自顶向下的方法来进行语法分析

#### 句型的短语、简单短语

【定义8】 给定文法G[Z], $w = xuy\in V^+$，为该文法的句型,

* 若 $Z\stackrel{*}\Rightarrow xUy$, 且$U\stackrel{+}\Rightarrow u$, 则u是句型w相对于U的**短语**；

* 若 $Z\stackrel{*}\Rightarrow xUy$, 且$U\Rightarrow u$, 则u是句型w相对于U的**简单短语**。

其中$U\in V_n，u \in V^+，x,y\in V^*$

【注】这里$V^*$意味着包含$V^0=\{ \epsilon \}$，x,y可以为空

#### 句柄

==句柄==：任一句型的最左简单短语称为该句型的句柄

#### 相关题目

对xx是句型相对于xx的短语、简单短语进行表述；判断句柄（见小测1——第4题）

![image-20211218104622127](编译技术 笔记.assets/image-20211218104622127.png)

### 2.4 语法树与二义性文法

#### 推导与语法（推导）树

语法（推导）树：句子( 句型）结构的图示表示法，它是有向图，由结点和有向边组成。用语法（推导）树来描述一个句子的语法结构。

子树：语法树中的某个结点（子树的根）连同它向下派生的部分所组成。

句型推导过程 <==> 该句型语法树的生长过程

【定义12】 对句型中最左简单短语（句柄）进行的归约称为**规范归约**

【定义13】 通过规范推导或规范归约所得到的句型称为规范句型。

#### 文法的二义性

##### 基本定义

（定义2.13）若对于一个文法的某一句子（或句型）存在两棵不同的**语法树**，则该文法是**二义性文法**，否则是无二义性文法。
换而言之，无二义性文法的句子只有一棵语法树，尽管推导过程可以不同。

* 最左规约=规范规约；最右推导=规范推导，二者为逆过程

##### 两种判定

判定1：

（定义2.13.1-p43）若文法中存在某个句子，它有两个不同的最右（或最左推导），则这个文法是二义性的。

判定2：

（定义2.13.2-p43）若文法中存在某个句子，它有两个不同的最左规约（规范规约），即在规约中某些规范句型的句柄不唯一，则这个文法是二义性的。

* 【注】对应地，可举例、找到一个句子，构造两颗不同语法树证明文法G的二义性。

{题目}另有二义性文法修改为无二义性文法的题目

##### 二义性文法例子

文法$G[E]$：
$$
E::=E+E\ |\ E*E\ |\ (E)\ |\ i
$$
句子$i+i*i$具有二义性

### 2.5 符号串的分析

1. 自顶向下分析
2. 自底向上分析

### 2.6 有关文法的使用性质

#### 对文法的限制

1. 希望文法无二义性
2. 不能有$U::=U$这样的规则，这是**有害规则**，它会引起二义性
3. 不能有多余规则，包括：
   * 不可达符号：始终用不到的规则；
   * 不活动符号：用此规则无法终结，如$<c>::=<c>f$

#### 压缩文法

【定义2.14】若某文法中无有害规则或多余规则，则称该文法是压缩过的或化简过的。

此时，无此3种情况：

1. 左递归；
2. 二义性；
3. 多余/不可达

### 2.7 扩充的BNF表示和语法图 

略

### 2.8 文法和语言分类

句子的分析、有关文法的实用限制、文法的其它表示法（略）

#### 文法和语言类型

文法和语言分类：0型、1型、2型、3型
这几类文法的差别在于对产生式（语法规则）施加不同的限制。

#### 0型文法

定义描述：
$$
P： u ::= v\\
其中 u\in V^+，v\in V^*, \ V = V_n \cup V_t
$$

* 0型文法称为**短语结构文法**。规则的左部和右部都可以是符号串，一个短语可以产生另一个短语

* 0型语言：L0 这种语言可以用图灵机(Turing)接受

#### 1型文法

定义描述：
$$
P： xUy ::= xuy\\
其中 U\in V_n，x、y、u\in V^*
$$

* 称为上下文敏感或**上下文有关**。也即只有在x、y这样的上下文中才能把U改写为u
* 1型语言：L1 这种语言可以由一种线性界限自动机接受

#### 2型文法

$$
P： U ::= u\\
其中 U\in V_n，u\in V^*
$$

* 称为上下文无关文法。也即把U改写为u时，不必考虑上下文。
  (1型文法的规则中x，y均为 ε 时即为2型文法）
  注意：2型文法与BNF表示相等价。
* 2型语言：L2 这种语言可以由下推自动机接受。

#### 3型文法

$$
P： U ::= t\\
或 U ::= Wt \ (若U::= tW 右线性)\\
其中 U、W\in V_n, t\in V_t
$$

* 3型文法称为**正则文法**。它是对2型文法进行进一步限制
  * 左线性文法：非终结符W在左；
  * 右线性文法：非终结符W在右；
* 3型语言：L3 又称正则语言、正则集合这种语言可以由有穷自动机接受

#### 性质

* 根据上述讨论，这三种文法确定的语言，$L_0 \supset L_1 \supset L_2 \supset L_3$
* 0型文法可以产生L0、L1、L2、L3；但2型文法只能产生L2，L3不能产生L0，L1；3型文法只能产生L3

#### 相关题目

简单判别一个文法是几型文法：（见小测1——第4题）

* 3型正则文法需满足，每一推导规则都包含终结符a，或者是组合形式的Wa，若推出的是AB，不是3型；
* 其余与上下文无关的是2型；
* 有关的是1型；
* 任意文法都是0型；

## 第05-06讲 词法分析

### 3.1 词法分析程序的功能

#### 任务

任务：依据文法（词法）分析和识别单词。

引入（有穷状态）自动机：是另一种抽象 Σ*上的语言 L 的方法：字母表Σ，状态集Q，初始状态s，状态转移函数，接受状态

#### 三个核心功能

1. 词法分析：根据词法规则识别及组合单词，进行词法检查。
2. 对数字常数完成数字字符串到二进制数值的转换。
3. 删去空格字符和注释。

### 3.2 单词种类

单词：是语言的基本语法单位，一般语言有四大类单词：

1. 语言定义的关键字或保留字（如BEGIN、END、IF）
2. 标识符（变量名）
3. 常数
4. 分界符（运算符） （如+、-、*、/、;、（、） ……）

### 3.3 正则文法和状态图

左线性文法的状态图的画法：

1. 每个非终结符设一个状态；
2. 设一个开始状态S；
3. 若Q::=T, Q ∈Vn,T ∈Vt,
4. 若Q::=RT, Q、R∈Vn,T ∈Vt,
5. 加上开始状态和终止状态标志

【注】

* 画法基本是：每个非终结符W作为一个状态，后面U=Wa则从W状态输入a跳转到U状态
* 初态为S（箭头标注”开始“），终态为Z（双圆圈）；

可看教材p64例子/05讲ppt-p41

{题目}检查句子是否为文法的合法句子；根据状态图写文法

### 3.4 词法分析程序的设计与实现

==见教材p73第三章部分==

如：预读符号getsym()、出错error()、调用子程序stmtA()、主函数main()

{题目}作业里有需要写词法分析程序算法

### 11.1 正则文法与正则表达式

#### 正则表达式相等关系

正则表达式相互转换,等价证明。经典性质如：
$$
\begin{align}
r^{*}&=(r|\epsilon)^*\\
r^{* *}&=r^*\\
(r|s)^*&=(r^*s^*)^*
\end{align}
$$
此外，还有分配律、结合律、交换律

### 11.2 有穷自动机

#### 确定的有穷自动机（DFA）

一个确定的有穷自动机（DFA）M是一个五元式：$M=(S,\sum,\delta,s_0,Z)$

每个字符含义：

* S —有穷状态集
* Σ —输入字母表
* δ —映射函数(也称状态转换函数)
  S×Σ→S
  δ(s,a)=s’ , s, s’ ∈S, a∈Σ
* s0 —初始状态，s0 ∈S
* Z—终止状态集，$Z\subseteq S$

#### 由正则表达式构造NFA(DFA)

分为几类情况画对应的NFA形式：

1. a|b；
2. a*；
3. ab

#### NFA确定化

##### $\epsilon$闭包

【定义1】集合I的ε-闭包：
令I是一个状态集的子集，定义ε-closure（I）为：
1）若s∈I，则s∈ε-closure（I）；
2）若s∈I，则从s出发经过任意条ε弧能够到达的任何状态都属于ε-closure（I）。
状态集ε-closure（I）称为I的ε-闭包。

##### 状态集合

【定义2】 令I是NFA M’的状态集的一个子集, a∈Σ
定义：$I_a=\epsilon-closure(J)$
其中，$J=\cup_{S\in I}∪δ(s,a)$

* J是从状态子集I中的每个状态出发,经过标记为a的弧而达到的状态集合。
* Ia是状态子集,其元素为J中的状态,加上从J中每一个状态出发通过ε弧到达的状态。

##### 状态转换矩阵

* 从起点S开始，对每个I-闭包，考察输入为每个字符时的状态转移变化情况，每一个闭包状态再相应转换到新的状态，直到覆盖全部状态

示意图（见06讲-p43）：

{例题}可参考最后的习题3

#### DFA最小化

* 用一个二维表格考察每两个状态之间能否合并
* 判定标准包括：终态不可与非终态合并；不可达状态

#### 由DFA构造正则表达式、文法

* 注意起始状态S、终止状态Z（双圆圈）；
* 每个节点是一个非终结符，符号作为状态间转移条件；
* 对每个状态W分析“入度”，从而得出类似W::=Aa|Bb

### 11.3 词法分析程序的自动生成器

略

## 第07-08讲 语法分析

### 基本概述

* 语法分析的任务：根据**语法规则**（即语言的文法），分析并识别出各种语法成分，如表达式、各种说明、各种语句、过程、函数等，并进行**语法正确性检查**。

两种不同的分析方法：

#### 自顶向下分析

自顶向下（Top-Down）分析：推导（Derivations）
$$
若 Z\mathop{\Rightarrow}_{G[Z]}^+S，
则S\in L(G[Z])，
否则S\notin L(G[Z])
$$
主要问题：

* 左递归问题；
* 回溯问题；

主要方法：

* 递归子程序法；
* LL分析法；

#### 自底向上分析

自底向上（Bottom-Up）分析：规约（Reductions）
$$
若 Z\mathop{\Leftarrow}_{G[Z]}^+S，
则S\in L(G[Z])，
否则S\notin L(G[Z])
$$
主要问题：

* 句柄的识别；

主要方法：

* 算符优先分析法；
* LR分析法；

### 4.1 自顶向下分析方法

#### 左递归问题

令U是文法的任一非终结符，文法中有规则$U::=U...$或者$U\stackrel{+}{\Rightarrow}U...$。这个文法是左递归的

* 自顶向下分析的基本缺点是：不能处理具有左递归性的文法。需要改写文法，且前后等价

##### 三种规则

【规则1】（提因子）：

$U::=xy|xw|...|xz$ 可替换为 $U::=x(y|w|...|z)$

【规则2】

$U::=x|y|...|z|Uv$ 可替换为 $U::=(x|y|...|z)\{v\}$

【规则3】将左递归规则改为右递归规则
$$
P::=P\alpha|\beta
$$
可改写为：
$$
P::=bP^{'} 和 P^{'}::=aP^{'}|\epsilon
$$

* 另外可能还有间接左递归的情况，需注意代入处理

#### 回溯问题

##### 基本概念

* 定义：分析工作要部分地或全部地退回去。

* 造成回溯的条件：文法中，对于某个非终结符号的规则其右部有多个选择，并根据所面临的输入符号不能准确地确定所要的选择时，就可能出现回溯。

* 回溯带来的问题：严重的低效率，只有在理论上的意义而无实际意义。

设文法G（不具左递归性），$U\in V_n$，$U::=\alpha_1|\alpha_2|\alpha_3$

定义首符号集FIRST
$$
FIRST(a_i)=\{a|\alpha_i \stackrel{*}{\Rightarrow} a...,a\in V_t \}
$$
为避免回溯，对文法的要求是：
$$
FIRST(a_i)\cap FIRST(a_j)=\phi(i\neq j)
$$

##### 消除回溯的方法

1. 改写文法：对具有多个右部的规则**反复**提取左因子。（如检查V和W的首符号是否相交）
2. 超前扫描（偷看）：当文法不满足避免回溯的条件时，即各选择的首符号相交时，可以采用超前扫描的方法，即向前侦察各输入符号串的第二个、第三个符号来确定要选择的目标

##### 无回溯的条件

不带回溯的充分必要条件是：对于G的每一个非终结符A的任意两条规则A::=α|β,下列条件成立：
$$
FIRST(\alpha) ∩ FIRST(\beta) = \varnothing\\
若\beta \stackrel{*}{\Rightarrow} \epsilon, 则FIRST(\alpha) \cap FOLLOW(A) = \varnothing
$$

### 文法满足的条件

（p83）为实现不带回溯的自顶向下分析，文法需满足下述两个条件：

1. 文法是非左递归的；
2. 文法的任一非终结符号，若其规则右部有多个选择（候选式）时，那么，各选择所推出的终结符号串的头符号集合两两不相交；

### 12.1 LL(1)分析方法

#### LL（1）文法含义

LL（1）文法是一种自顶向下的分析方法（与递归下降类似）。（另一个有趣的结论：LL（k）文法是无二义的）

* 第一个L：从左向右分析 (Left to right)
* 第二个L：产生“最左推导”(Left-most derivation)
* k=1：向前查看“k=1”个符号

#### FIRST集

$$
FIRST(\alpha)={a|\alpha \stackrel{*}{\Rightarrow}a...,a\in V_t}
$$

* α∈V* , 若$\alpha\stackrel{*}{\Rightarrow}\epsilon$，则ε∈FIRST(α)
* 该集合称为α的头符号集合。

构造FIRST集的算法：

1. 若$X_i\in V_t$且，则 FIRST(Xi) = {Xi}；

2. 若$X_i\in V_n$且且 Xi∷=a…..|ε， a ∈Vt。则FIRST(Xi)={a，ε}；

3. 若$X_i\in V_n$且$X_i::=y_1y_2...y_k$，则按如下顺序计算$FIRST(X_i)$：$FIRST(X_i)\Leftarrow FIRST(y_1)-\{\epsilon\}$；

   若ε∈FIRST(y1) 则将FIRST(y2)-{ε}加入FIRST(Xi)；

   以此类推...

【注】FIRST集合中可以有 ε

简单整理：

* 若右部终结符，直接加入FIRST；
* 若右部有空$\epsilon$，加入FIRST集；
* 若右部非终结符W，则FIRST(W)-{ε}加入FIRST集；
* 若右部有可“透过的”（即可推导出ε的非终结符），将其后面的符号加入FIRST；

#### FOLLOW集

##### 定义

A的后继符号集FOLLOW（A）：假定S是文法的开始符号，对于G的任何非终结符A，定义：
$$
FOLLOW(A)=\{a|S\mathop{\Rightarrow}^*...Aa...,a\in V_t\}
$$

* 特别地，若$Z\mathop{\Rightarrow}^*...A$ 则 #∈FOLLOW(A)

##### 构造集合FOLLOW的算法

设S, A, B∈Vn，连续使用以下规则，直至FOLLOW集合不再扩大

(1) 若S为识别符号,则把“#”加入FOLLOW(S)中
(2) 若A∷=αBβ (β≠ε),则把 FIRST(β)-{ε} 加入FOLLOW(B)
(3) 若A∷=αB 或A∷=αBβ， 且βε则把FOLLOW(A)加入FOLLOW(B)
注：FOLLOW集合中不能有 ε

一个简明的例子（08讲-p28）：

![image-20211206084837029](编译技术 笔记.assets/image-20211206084837029.png)

简单整理：

* 若S是初始识别符号，#加入FOLLOW；
* 右部，S后面跟着的终结符号a加入FOLLOW；或非终结W的FIRST(W)-{ε}加入；若有ε注意“透过”；
* 左部，诸如$A\rightarrow B$，则FOLLOW（A）加入FOLLOW（B）；若有ε注意“透过”

#### LL（1）分析表

基本思想：当文法中某一非终结符呈现在栈顶时, 根据当前的输入符号,分析表应指示要用该非终结符的哪一条规则去匹配输入串(即进行一步最左推导)

构造算法：
设A∷=αi为文法中的任意一条规则，a为任一终结符或#。
1、若a ∈FIRST（ αi ），则A::= αi ==> M[A,a]表示：A在栈顶，输入符号是a，应选择αi 去匹配
2、若αi =ε或αi  ε,而且a ∈FOLLOW（A），则A::= αi ==>M[A,a]，表示A已经匹配输入串成功，其后继符号终结符a由A后面的语法成分去匹配。
3、把所有无定义的M[A,a]都标上error

简单说：

* 对$FIRST(\alpha)$中的每个终结符a，在表中对应处填入对应规则；
* 若$FIRST(\alpha)$中有ε，将FOLLOW(A)中的每个符号置为$A\rightarrow\epsilon$；
* 其余空着不填；
* “#”记得填入符号集中，在表头中

08讲-p69的例子：

![image-20211220111233358](编译技术 笔记.assets/image-20211220111233358.png)

#### 证明文法是LL（1）

书十二章—p261

一个文法是LL(1)的，当且仅当对于G的每一个终结符A的任何两条不同规则$A::=\alpha|\beta$，下面的条件成立：

1. $FIRST(\alpha)\cap FIRST(\beta)=\varnothing$
2. 假若$\beta \stackrel{*}{\Rightarrow}\epsilon$，那么$FIRST(\alpha)\cap FOLLOW(A)=\varnothing$

* 其实可认为是LL1分析表中，同一个单元格无推导规则冲突

## 第09讲 语义分析

任务：对识别出的各种语法成分进行**语义分析**（理解意思），并产生相应的**中间代码**。

作用域：指代程序中的一个区域

## 第10讲 符号表管理

### 5.1 概述

* 符号表的定义：在编译过程中,编译程序用来记录源程序中各种名字的特性信息, 所以也称为名字特性表。

* 必要性与作用

  当编译程序编译到**引用**所声明的变量时(赋值或引用其值)，要进行**语法语义正确性检查**(类型是否符合要求)和生成相应的目标程序，这就需要**查符号表**以取得相关信息。

* 有关符号表的操作：填表和查表

### 5.2 符号表的组织与内容

#### 结构与内容

符号表的基本结构：

| 名字 | 特性(信息) |
| ---- | ---------- |
| ...  | ...        |
|      |            |

* “名字”域: 存放名字，一般为标识符的符号串,也可为指向标识符字符串的指针。

* “特性”域: 可包括多个子域 , 分别表示标识符的有关信息，如：

  > 名字(标识符)的种类:简单变量、函数、过程、数组、标号、参数等
  > 类型：如整型、浮点型、字符型、指针等
  > 性质：变量形参、值形参等
  > 值：常量名所代表的数值
  > 地址：变量所分配单元的首址或地址位移
  > 大小：所占的字节数
  > 作用域的嵌套层次:

#### 组织方式

1. 统一符号表：不论什么名字都填入统一格式的符号表中
2. 对于不同种类的名字分别建立各种符号表：
   符号表表项应按信息量最大的名字设计,填表、查表比较方便, 结构简单, 但是浪费大量空间。
3. 折中办法：大部分共同信息组成统一格式的符号表，特殊信息另设附表,两者用指针连接。

### 5.3 非分程序结构语言的符号表组织

非分程序结构语言：每个可独立进行编译的程序单元是一个不包含有子模块的单一模块，如FORTRAN语言。

### 5.4 分程序结构语言的符号表组织

#### 作用域与处理方式

分程序结构语言：模块内可嵌入子模块

处理办法：建查符号表均要遵循标识符的作用域规定进行。

* 建表：不能重复,不能遗漏；
* 查表：按标识符作用域；

栈式符号表

{题目}画符号表、运行栈，参考最末尾的习题2

## 第11讲 运行时存储组织管理

运行时的存储组织及管理：目标程序运行时所需存储空间的组织与管理以及源程序中变量存储空间的分配。

存储分配两种方式：静态存储分配、动态存储分配

### 6.2 静态存储分配

定义：在**编译阶段**由**编译程序**实现对存储空间的管理和为源程序中的变量分配存储的方法。

条件：如果在编译时能够确定源程序中变量在运行时的数据空间大小，且运行时不改变，那么就可以采用静态存储分配方法。

* 特点：不是所有数据空间大小都能在编译过程中确定

分配策略

由于每个变量所需空间的大小在编译时已知，因此可以用简单的方法给变量分配目标地址。

* 开辟一数据区。（首地址在加载时定）
* 按编译顺序给每个模块分配存储空间。
* 在模块内部按顺序给模块的变量分配存储，一般用相对地址，所占数据区的大小由变量类型决定。
* 目标地址填入变量的符号表中。

### 6.3 动态存储分配

定义：在目标程序**运行阶段**由**目标程序**实现对存储空间的组织与管理，和为源程序中的变量分配存储的方法。

特点：

* 在目标程序运行时进行变量的存储分配。
* 编译时要生成进行动态分配的目标指令。

分配策略: 整个数据区为一个堆栈

(1) 当进入一个过程时，在栈顶为其分配一个数据区。

(2) 退出时，撤消过程数据区。

#### 活动记录

一个典型的活动记录可以分为三部分：

| 局部数据区 |
| 参数区     |
| display区  |

1. 局部数据区：存放模块中定义的各个局部变量。

2. 参数区： 存放隐式参数和显式参数。

   （11讲-p26）

   ![image-20211220161535559](编译技术 笔记.assets/image-20211220161535559.png)

   * prev abp ：存放调用模块记录基地址,函数执行完时,释放其数据区，数据区指针指向调用前的位置
   * ret addr：返回地址，即调用语句的下一条执行指令地址
   * ret value ： 函数返回值(无值则空)
   * 形参数据区: 每一形参都要分配数据空间,形参单元中存放实参值或者实参地址

3. display区：存放各外层模块活动记录的基地址。

#### 运行时的地址计算

变量二元地址(BL、ON)

* BL：变量声明所在的层次。

  【注1】可得到该层数据区开始地址

  【注2】并列过程具有相同层次

* ON：相对于显式参数区的开始位置的位移。（相对地址）

设要访问的变量的二元地址为：（BL，ON)
BL：嵌套深度 ON：变量在本层的编号

计算公式：
$$
addr = 
\begin{cases}
abp+(BL-1)+nip+ON, &\text{BL=LEV时}\\
display[BL]+(BL-1)+nip+ON, &\text{BL<LEV时}\\
error，&\text{地址错，不合法的模块层次}
\end{cases}
$$
参数说明：

* LEV：当前嵌套深度；

* BL-1：Display区大小；
* nip：隐式参数区大小；

## 第12讲 中间表示与错误处理

### 7.1 波兰表示

波兰表示由波兰逻辑学家 J.Lukasiewicz 提出

* 前缀表达：（波兰表达）；<操作符><操作数序列>。例如：+ 3 5
* 后缀表达：（逆波兰表达）；<操作数序列><操作符>。例如：3 5 +

#### 与语法树的联系

例： (A+B * C) / ( D*E – (F+G) / (H+I))

前序遍历（根左右）：/+A*BC-*DE/+FG+HI （波兰表达）

后序遍历（左右根）：ABC*+DE*FG+HI+/-/ （逆波兰表达）

#### if控制流波兰表示

if \<expr\> then \<stmt1\> else <stmt2\>

波兰表示为：

\<expr\> \<label1\> BZ \<stmt1\> \<label2\> BR <stmt2\>

* BZ是二目操作符，如果<expr>计算结果为0（false），则产生一个到<label1>的转移，<label1>是<stmt2>头符号所在的位置；
* BR是一个一目操作符，产生一个到<label2>的转移，<label2>是紧跟在<stmt2>后面的符号所在的位置

### 7.2 N-元表示

* 在该表示中，每条指令由n个域组成，通常第一个域表示操作符，其余为操作数。
* 常用的n元表示是：三元式、四元式。

三元式：

操作符 | 左操作数 | 右操作数

四元式表示（三地址表示）（TAC）：

操作符 | 操作数1 | 操作数2 | 结果

### 7.3 抽象语法树

抽象语法树：用树型图的方式表示中间代码。**操作数**出现在叶节点上，**操作符**出现在中间结点

DAG图：Directed Acyclic Graphs 有向无环图，指语法树的一种归约表达方式

### 错误处理

此部分非重点

#### 8.1 概述

1. 必备功能之一
正确的源程序：通过编译生成目标代码
错误的源程序：通过编译发现并指出错误
2. 错误处理能力
(1) 诊察错误的能力
(2) 报错及时准确
(3) 一次编译找出错误的多少
(4) 错误的改正能力
(5) 遏止重复的错误信息的能力

#### 8.2 错误分类

从编译角度，将错误分为两类：语法错误和语义错误
语法错误：源程序在语法上不合乎文法
如：A[ I， J := B +* C
语义错误主要包括：程序不符合语义规则或超越具体计算机系统的限制

#### 8.3 错误的诊察和报告

错误诊察：
1. 违反语法和语义规则以及超过编译系统限制的错误。
编译程序: 语法和语义分析时
（语义分析要借助符号表）
2. 下标越界，计算结果溢出以及动态存储数据区溢出。
目标程序: 目标程序运行时
对此，编译程序要生成相应的目标程序作检查和进行处理

错误报告：
1. 出错位置：即源程序中出现错误的位置。（实现：行号计数器）
2. 出错性质：

#### 8.4 错误处理技术

发现错误后，在报告错误的同时还要对错误进行处理，以方便编译能进行下去。目前有两种处理办法：

1. 错误改正：指编译诊察出错误以后，根据文法进行错误改正。

2. 错误局部化处理：指当编译程序发现错误后，尽可能把错误的影响限制在一个局部的范围，避免错误扩散和影响程序其他部分的分析。

## 第13讲 语法制导翻译

### 9.1 翻译文法(TG)和语法制导翻译

输入文法：未插入动作符号时的文法。由输入文法可以通过推导产生输入序列。

翻译文法：插入动作符号的文法。由翻译文法可以通过推导产生活动序列。

活动序列：由翻译文法推导出的符号串，由终结符和动作符号组成。

* 从活动序列中，抽去动作符号，则得输入序列（i+i)\*i

* 从活动序列中，抽去输入序列，则得动作序列，执行动作序列，则完成翻译任务：
  $$
  @i@i@+@i@* \Rightarrow ii+i*
  $$

【定义9.1】

**翻译文法**是上下文无关文法，其终结符号集由输入符号和动作符号组成。由翻译文法所产生的终结符号串称为**活动序列**。

语法制导翻译的实现方法：在文法的适当位置插入语义动作符号，当按文法分析到动作符号@时就调用相应的语义子程序，完成翻译任务。

#### 对偶

第一个元素是被翻译（输入语言）的符号串，第二个元素是翻译该符号串时的动作序列、或操作后产生的新符号串

p166-第5题

### 9.2 属性翻译文法(ATG)

#### 基本概念

* 在翻译文法的基础上，可以进一步定义**属性文法**，翻译文法中的符号，包括终结符、非终结符和动作符号均可带有属性，这样能更好的描述和实现编译过程。
* 属性分为2种：综合属性$(\uparrow)$、继承属性$(\downarrow)$

#### L-ATG

L-属性翻译文法（L-ATG）

这是属性翻译文法中较简单的一种。其输入文法要求是LL(1)文法，可用自顶向下分析构造分析器。在分析过程中可进行属性求值。

##### 继承属性与综合属性求值

产生式$A\rightarrow BC$，A、B、C属性的求法与顺序（p174—六规则）：

* A的继承属性：
* B的继承属性：
* B的综合属性：
* C的继承属性：
* C的综合属性：
* A的综合属性：（注意A综合最后算）

#### SL-ATG

简单赋值形式的L_属性翻译文法(SL-ATG)

定义9.4 一个L-ATG被定义为简单赋值形式的(SL-ATG)，当且仅当满足如下条件：
1. **产生式右部符号的继承属性**$\downarrow$是一个常量，它等于左部符号的继承属性值或等于出现在所给符号左边符号的一个综合属性值。
2. **产生式左部非终结符号的综合属性**$\uparrow$是一个常量，它等于左部符号的继承属性值或等于右部符号的综合属性值。

* 性质（p174）：除动作符号外，其余符号的属性求值规则是其右部属性或常量

#### 相关题目

给定一个L-ATG，如何找一个等价的赋值形式的L-ATG?

考虑产生式：
$$
<A>\longrightarrow a_{\uparrow R}<B>_{\uparrow S}<C>_{\downarrow I}, \ I:=f(R,S)
$$
思路: 把求值函数变成一个动作@f。

第一步：设动作符号“@ f ” 表示函数f求值，该动作符号有两个继承属性和一个综合属性。
$$
@f_{\downarrow I_1,I_2 \uparrow S_1}
$$
且
$$
S_1:=f(I_1, I_2)
$$
第二步：修改产生式
1. 插入“@ f ” （在适当位置）
2. 引进新的复写规则（将R , S 赋给I1和I2, f值赋给S1 ）
3. 删去原有包含f 的规则

$$
<A>\longrightarrow a_{\uparrow R}<B>_{\uparrow S}
@f_{\downarrow I_1,I_2 \uparrow S_1}
<C>_{\downarrow I}\\
I_1:=R,\ I_2=S,\ S_1:=f(I_1,I_2),\ I:=S_1
$$

### 9.3 自顶向下语法制导翻译

翻译文法的自顶向下翻译——递归下降翻译器

按翻译要求，在文法中插入语义动作符号，在分析过程中调用相应的语义处理程序，完成翻译任务。

9.3.2 属性文法自顶向下翻译的实现——递归下降翻译器

方法：

对于每个非终结符号都编写一个翻译子程序（过程）。根据该非终结符号具有的属性数目，设置相应的参数。

{题目}一个求括号深度的小测，习题4

## 第14-15讲 语义分析与代码生成

前两节课（符号表+运行时存储）：为代码生成做“需求分析”

上一节课（语法制导翻译）：为代码生成做工具准备

栈式抽象机指令代码

### 声明语句的处理

编译程序处理声明语句要完成的主要任务为：
编译程序的任务：

1) 分离出每一个被声明的实体，并把它们的名字填入符号表中
2) 把被声明实体的有关特性信息尽可能多地填入符号表中

 对于已声明的实体，在处理对该实体的引用时要做的事情：

1) 检查对所声明的实体引用（种类，类型等）是否正确
2) 根据实体的特征信息，例如类型，所分配的目标代码地址（可能为数据区单元地址，或目标程序入口地址）生成相应的目标代码



变量声明

常量声明

#### 数组变量声明

一个计算地址的公式：绝对地址=
$$
ADDR = LOC+\sum_{i=1}^n[V(i)-L(i)]P(i)\times E
$$
符号说明

* L（i）：第i维下界
* U（i）：第i维上界
* P（i）：大小，如下计算

其中，
$$
P(i)=\prod_{j=i+1}^n[U(j)-L(j)+1]
$$
加速计算的想法：提前计算不变部分RC
$$
\begin{align}
ADDR &= LOC+\sum_{i=1}^n[V(i)-L(i)]P(i)\times E\\
&= LOC+\sum_{i=1}^n V(i)\times P(i)\times E - \sum_{i=1}^n V(i)\times L(i)\times E\\
&= LOC+\sum_{i=1}^n V(i)\times P(i)\times E + RC\\
\end{align}
$$
则$RC=- \sum_{i=1}^n V(i)\times L(i)\times E\\$不变，提前计算

可填写数组模板（数组信息向量表）：可选择放入运行栈中

#### 函数声明

略

### 表达式及简单变量引用

#### 表达式：类型检查

偏序关系的类型

语言结构中隐含的类型

#### 表达式：类型检查+数组变量引用

逻辑运算与逻辑表达式

赋值语句

过程调用与返回

## 第16-18讲 代码优化

### 代码优化

指编译程序为了生成高质量的目标程序而做的各种加工和处理

* 目的：提高目标代码运行效率
* 原则：进行优化必须严格遵循“不能改变原有程序语义”原则
* 主要思想：
  * 用开发时的开销代替运行时开销
  * 循环：程序中的“8-2原则”（为减少循环执行时间所进行的优化对减少整个程序运行时间有很大的意义）

#### 优化代价

只要做些简单的处理，便能得到明显的优化效果若要进一步提高优化效果，就要逐步付出更大的代价。【关于边际效益】

#### 优化方法分类

* 与机器无关的优化技术：即与目标机无关的优化，通常是在中间代码上进行的优化。
  – 如：数据流分析 ，常量传播，公共子表达式删除，死代码删除，循环交换，代码内联等等
* 与机器相关的优化技术：充分利用系统资源，（指令系统，寄存器资源）

#### 另一种分类

* 局部优化技术

  指在**基本块内**进行的优化。例如，局部公共子表达式删除

* 全局优化技术

  **函数/过程内**进行的优化。跨越基本块。例如，全局数据流分析、循环优化

* 跨函数（过程间）优化技术

  整个程序范围内的优化。例如，函数内联、函数间常量传播、跨函数别名分析，逃逸分析，死调用/死函数删除，全局变量优化

### 14.1 基本块与流图

基本块定义：基本块中的代码是连续的语句序列；程序的执行（控制流）只能从基本块的第一条语句进入；程序的执行只能从基本块的最后一条语句离开

#### 算法14.1 划分基本块

1. 首先确定入口语句（每个基本块的第一条语句）的集合
   * 规则1：整个语句序列的第一条语句属于入口语句
   * 规则2：任何能由条件/无条件跳转语句转移到的第一条语句属于入口语句
   * 规则3：紧跟在跳转语句之后的第一条语句属于入口语句
2. 每个入口语句直到下一个入口语句，或者程序结束，它们之间的所有语句都属于同一个基本块

* 【简单概括来说】：（1）所有基本块以含goto的语句为截止；（2）goto到的位置（i）作为一个基本块的起始
* ==！==注意增加开始块和退出块

#### 流图

* 流图是一种有向图
* 流图的节点是基本块
* 如果在某个执行序列中，B2的执行紧跟在B1之后，则从B1到B2有一条有向边。我们称B1为B2的**前驱**，B2为B1的**后继**

### 14.2 基本块内优化

局部优化：指基本块内的优化

#### 1.利用代数性质（代数变换）

* 编译时完成常量表达式的计算，整数类型与实型的转换。
  例：a := 5+6+x → a := 11+x （常数合并）

* 下标变量引用时，其地址计算的一部分工作可在编译时预先做好（运行时只需计算“可变部分”即可）
  
* 运算强度削弱：用一种需要较少执行时间的运算代替另一种运算，以减少运行时的运算强度时、空开销）。如：
  
  > x**2 → x*x
  > 3*x → x+x+x
  > 8*x , 4*x 等 换成 左移运算
  > x/2 , x/16 等 换成 右移运算
  > x:=x+1 变为  INC x 指令
  > x/5 → x*0.2 等

#### 2. 常数合并和传播

* 复写传播：如 x:=y 这样的赋值语句称为复写语句。由于 x 和 y 值相同，所
  以当满足一定条件时，在该赋值语句下面出现的 x 可用 y 来代替。

  > x:=y ;				u:=2*y ;
  > x:=y ;	→    	 v:=x+1;
  > u:=2*x;				v:=y+1 ;

#### 3.删除冗余代码

* 冗余代码就是毫无实际意义的代码，又称死代码(dead code)或无用代码(useless code)。例如：

  > x := x + 0 ; x := x * 1 ;
  > 又例：
  > FLAG := TRUE
  > IF FLAG THEN…
  > …
  > ELSE …

#### 4.窥孔优化

窥孔优化关注在目标指令的一个较短的序列上，通常称其为“窥孔”

#### 5.消除公共子表达式

##### 算法14.2 构建DAG图的算法

消除公共子表达式（书p53）

* 输入：基本块内的中间代码序列
* 输出：完成局部公共子表达式删除后的DAG图

1. 首先建立节点表，该表记录了变量名和常量值，以及它们当前所对应的DAG图中节点的序号。该表初始状态为空。
2. 从第一条中间代码开始，按照以下规则建立DAG图。
3. 对于形如z = x op y的中间代码，其中z为记录计算结果的变量名，x为左操作数，y为右操作数，op为操作符：首先在节点表中寻找x，如果找到，记录下x当前所对应的节点号i；如果未找到，在DAG图中新建一个叶节点，假设其节点号仍为i，标记为x（如x为变量名，该标记更改为x0）；在节点表中增加新的一项(x, i)，表明二者之间的对应关系。右操作数y与x同理，假设其对应节点号
   为j。
4. 在DAG图中寻找中间节点，其标记为op，且其左操作数节点号为i，右操作数节点号为j。如果找到，记录下其节点号k；如果未找到，在DAG图中新建一个中间节点，假设其节点号仍为k，并将节点i和j分别与k相连，作为其左子节点和右子节点；
5. 在节点表中寻找z，如果找到，将z所对应的节点号更改为k；如果未找到，在节点表中新建一项(z, k)，表明二者之间的对应关系。
6. 对输入的中间代码序列依次重复上述步骤3～5。

【注】不必死记算法，随便画出DAG图就好（注意重定义变量重命名），可见最后习题6

##### 算法14.3 从DAG导出中间代码的启发式算法

* 输入：DAG图
* 输出：中间代码序列

1. 初始化一个放置DAG图中间结点的队列。
2. 如果DAG图中还有中间节点未进入队列，则执行步骤3，否则执行步骤5
3. 选取一个尚未进入队列，但其所有父节点均已进入队列的中间节点n，将其加入队列；或选取没有父节点的中间节点，将其加入队列
4. 如果n的最左子节点符合步骤3的条件，将其加入队列；并沿着当前节点的最左边，循环访问其最左子节点，最左子节点的最左子节点等，将符合步骤3条件的中间节点依次加入队列；如果出现不符合步骤3条件的最左子节点，执行步骤2
5. 将中间节点队列逆序输出，便得到中间节点的计算顺序，将其整理成中间代码序列

##### 数组、指针及函数调用的DAG图

* 当中间代码序列中出现了数组成员、指针或函数调用时，算法14.2需要作出一定的调整，否则将得出不正确的优化结果 。例如，以下情况不一定x=z：

  > x = a[i]
  > a[j] = y
  > z = a[i]

#### 公共子表达式删除

#### 死代码删除

* 观察变量活性：自底向上算，加入表达式右侧变量，移除左侧变量

### 14.3 全局优化

#### 数据流分析

*  用于获取数据在程序执行路径中如何流动的有关信息。例如：
  * 某个变量在某个特定的执行点（语句前后）是否还“存活”
  * 某个变量的值，是在什么地方定义的
  * 某个变量在某一执行点上被定义的值，可能在哪些其他执行点被使用
* 是局部优化、全局优化的基础

##### 数据流分析方程

考察在程序的某个执行点的数据流信息
$$
out[S]=gen[S]\cup (in[S]–kill[S])
$$

* S 代表某条语句（基本块，基本块集合，或语句集合）
* out[S]代表在该语句末尾得到的数据流信息
* gen[S]代表该语句本身产生的数据流信息
* in[S]代表进入该语句时的数据流信息
* kill[S]代表该语句注销的数据流信息

#### 活跃变量分析

活跃变量分析：了解变量x在某个执行点p是活跃的。

* 解释：变量x的值在p点或沿着从p出发的某条路经中会被使用，则称x在p点是活跃的

活跃变量信息对于寄存器分配，不论是全局寄存器分配还是临时寄存器分配都有重要意义

* 如果拥有寄存器的变量x在p点开始的任何路径上不再活跃，可以释放寄存器
* 如果两个变量的活跃范围不重合，则可以共享同一个寄存器

##### 数据流方程

$$
in[B]=use[B]\cup (out[B]–def[B])\\
out[B] = \cup_\text{B的后继基本块P}\ in[P]
$$

* out[B] = $\cup_\text{B的后继基本块P} in[P]$
* def[B]：变量在B中被定义（赋值）先于任何对它们的使用
* use[B]：变量在B中被使用先于任何对它们的定义
* 【注】意味着同一块B中，def[B]与use[B]是不相交的

##### 算法14.5 基本块的活跃变量数据流分析

输入：程序流图，且基本块的use集和def集已计算完毕
输出：每个基本块入口和出口处的in[B]和out[B]
方法：

1. 将包括代表流图出口基本块Bexit在内的所有基本块的in集合，初始化为空集。
2. 根据方程$in[B]=use[B]\cup (out[B]–def[B])$和$
out[B] = \cup_\text{B的后继基本块P}\ in[P]$
为每个基本块B依次计算集合 out[B] 和 in[B]
3. 如果计算得到in[B]与此前计算得出的in[B]不同，则循环执行步骤2，直到所有基本块的in[B]集合不再产生变化为止

#### 可（到）达定义分析

##### 数据流方程

$$
in[B]=\cup_\text{B的前驱基本块P}\ out[P]\\
out[B]=gen[B]\cup(in[B]-kill[B])
$$

##### 算法14.4 基本块的到达定义数据流分析

* 输入：程序流图，且基本块的kill[]和gen[] 已经计算完毕
* 输出：每个基本块入口和出口处的in和out集合，即in[B]和out[B]

1. 将包括代表流图出口基本块Bexit的所有基本块的out集合，初始化为空集。
2. 根据方程$in[B]=\cup_\text{B的前驱基本块P}\ out[P]$，$out[B]=gen[B]\cup(in[B]-kill[B])$，为每个基本块B依次计算集合in[B]和out[B]。
3. 如果某个基本块计算得到的out[B]与该基本块此前计算得出的out[B]不同，则循环执行步骤2，直到所有基本块的out[B]集合不再产生变化为止。

#### 使用-定义链数据流

先按到达定义分析，计算出每个基本块的gen、kill、in、out，用<基本块序号，块内中间代码序号>的表示方式表示

* 【注】注意最后还有$in[B_{exit}]$

之后对每个变量，构建多条链L，每条L中包含一个定义点与所有可到达的位置。拥有同样使用点的L可合并成同一个网W

之后按照网之间的冲突关系构建冲突图

{题目}见p356-第6题

#### 全局死代码消除

####  全局复写传播（常量传播）

目的：寻找所有可以被替换成常量的变量

#### 活跃变量与冲突图

关于变量冲突的判断：两个变量中的一个变量在另一个变量定义（赋值）处是活跃的，它们就是冲突的。

– 算法一：在每一个变量的定义点计算活跃变量

– 算法二：计算基本块入口处的活跃变量（in的集合），这些变量在该基本块中的定义点活跃，因而冲突。之后，在基本块内部，进一步计算每个定义点的活跃变量（基本块范围内计算）

– 基本块内是线性的，可降低计算复杂度



变量的定义-使用链（Define-Use链）：变量的某一定义点，以及所有可能使用该定义点所定义变量值的使用点所组成的一个链

### 支配属性

节点D支配节点N：如果从开始到N的每条路径都通过D

Dominance Frontier：支配边界：当前节点所能支配的边界Y是X的支配边界：当且仅当存在一个从X->Y的路径，且Y是这个路径上第一个不被X严格支配的节点

#### 静态单赋值（SSA）

SSA：Static Single Assignment 是一种基于三元式或四元式的中间语言的表示形式，其目的是支撑静态优化

分支节点

Φ函数：（phi）通常放置在基本块的开始，根据控制流选择变量的值

放置Φ函数

从减少开销角度，算法高效率角度，尽可能少放（仅在支配边界）

#### 循环优化

循环不变式的代码外提
不变表达式：不随循环控制变量改变而改变的表达式或子表达式

```java
for(i=E1; i<=E3 ; i+=E2) {
    S=0.2*3.1416*R;	//可外提
    P=0.35*i;
    V=S*P;
}
```

（2）循环展开
将构成循环体的代码（不包括控制循环的测试和转移部分），重复产生许
多次（这可在编译时确定），而不仅仅是一次，以空间换时间

（3）归纳变量的优化和条件判断的替换

（4）其它循环优化方法
• 把多重嵌套的循环变成单层循环。
• 把n个相同形式的循环合成一个循环等。

（5） in_line 展开
把过程（或函数）调用改为in_line展开可节省许多处理过程
（函数）调用所花费的开销。

## 第19-20讲 目标代码生成

面向目标体系结构 的代码生成和优化技术

流水线下的指令顺序移动

### 指令集架构

* 栈式
* 累加器式
* 寄存器-内存式
* 寄存器-寄存器式

### 15.3 寄存器分配

#### 引用计数

* 通过统计变量在函数内被引用的次数，并根据被引用的特点赋予不同的权重，最终为每个变量计算出一个唯一的权值
* 根据权值的大小排序，将全局寄存器依次分配给权值最大的变量

原则：如果一个局部变量被访问的次数较多，那么它获得全局寄存器的机会也较大

分配算法：如果有N个全局寄存器可供分配，则前N个变量拥有全局寄存器，其余变量在程序运行栈（活动记录）分配存贮单元

#### 线性扫描

线性扫描，看在每个程序执行点时哪些变量是活跃、共存的

#### 图着色

一种启发式图着色算法：Chaitin-Briggs算法 p74开始

步骤1、找到第一个连接边数目小于K的结点，将它从图G中移走，形成图G’

步骤2、重复步骤1，直到无法再从G’中移走结点

步骤3、在图中选取适当 的结点，将它记录为“不分配全局寄存器”的结点，并从图中移走

步骤4、重复上述步骤，直到图中仅剩余1个结点

步骤5 按照结点移走的反向顺序将点和边添加回去，并分配颜色

## 第21讲 算符优先分析

特点：仿效四则运算过程，预先规定相邻终结符之间的优先关系，然后利用这种优先关系来确定句型的“句柄” ，并进行归约。

(1) 先确定终结符之间的优先关系

有两种不同的“相邻”判定规则

方式一：

如果 E→…ab… ，且a,b均为终结符，则ab可以相邻。First(E) = { (, i}

|      | 合法句子                     | 可以相邻     | 不可相邻     |
| ---- | ---------------------------- | ------------ | ------------ |
| +    | E->i+i, E->i+(i+i)           | {(, i}       | {+, *, ), #} |
| *    | E->i\*i, E->i\*(i+i)         | {(, i}       | {+, *, ), #} |
| （   | E->(i),E->((i+i)+i)          | {(, i}       | {+, *, ), #} |
| ）   | E->(i)+i, E->(i)*I, E->((i)) | {+, *, ), #} | {(, i}       |
| i    | E->i+i, E->i*i, E->(i)       | {+, *, ), #} | {(, i}       |
| #    | E->i+i, E->(i)               | {(, i, #}    | {+, *, )}    |

相邻关系表为：

|      | +    | *    | i    | (    | )    | #    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| +    | ERR  | ERR  | ?    | ?    | ERR  | ERR  |
| *    | ERR  | ERR  | ?    | ?    | ERR  | ERR  |
| i    | ?    | ?    | ERR  | ERR  | ?    | ?    |
| (    | ERR  | ERR  | ?    | ?    | ERR  | ERR  |
| )    | ?    | ?    | ERR  | ERR  | ?    | ?    |
| #    | ERR  | ERR  | ?    | ?    | ERR  | DONE |

* 放宽后的标准：构造一个句子，使得终结符之间有非终极符E，也算相邻。如下述情况，表明i可与all相邻：

  E->i==+i==, E->i==+(==i+i)
  E->E==+==E==*==E, E->E==+==E==+===E, E->(E==+==E==)===

相邻关系表为：

|      | +    | *    | i    | (    | )    | #    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| +    | ?    | ?    | ?    | ?    | ?    | ?    |
| *    | ?    | ?    | ?    | ?    | ?    | ?    |
| i    | >    | >    | ERR  | ERR  | >    | >    |
| (    | ?    | ?    | ?    | ?    | ?    | ERR  |
| )    | ?    | ?    | ERR  | ERR  | ?    | ?    |
| #    | ?    | ?    | <    | <    | ERR  | DONE |

【注】上表及内容sb，基本无用！

### 12.3 算符优先分析法

#### 算符优先文法

算符文法（OG）的定义：若文法中无形如U∷= ···VW···的规则，这里V,W∈Vn，则称G为OG文法，也就是算符文法。

优先关系的定义：

若G是一OG文法，$a,b\in V_t$ , $U,V,W\in V_n$
分别有以下三种情况：

1. a=b iff 文法中有形如 U∷= ···ab···或U∷= ···aVb···的规则。
2. a<b iff 文法中有形如 U∷=···aW···的规则，其中W$\mathop{\Rightarrow}\limits^+$ b···或W$\mathop{\Rightarrow}\limits^+$ Vb··· 。
3. a>b iff 文法中有形如 U∷=···Wb···的规则, 其中W$\mathop{\Rightarrow}\limits^+$ ···a或W$\mathop{\Rightarrow}\limits^+$ ···aV 。

OPG需保证每一小格确定

#### FIRSTVT集

构造算法：

1. 若有规则$U∷= b...$或$U∷= Vb...$(存在$U\mathop{\Rightarrow}\limits^+b…$或U$\mathop{\Rightarrow}\limits^+$Vb…)则$b\in FIRSTVT(U)$
2. 若有规则$U∷= V...$且$b\in FIRSTVT(V)$, 则$b\in FIRSTVT(U)$

* 简单说，从前向后看，包含所有可“看见”的终结符（透过所有非终结符）

#### LASTVT集

与FIRST类似，构造算法：

1. 若有规则U::=…a或U::=…aV,则$a\in LASTVT(U)$
2. 若有规则U::=…V,且a∈LASTVT(V), 则$a\in LASTVT(U)$

* 简单说，从后向前看，包含所有可“看见”的终结符（透过所有非终结符）

#### 构造优先表的算法

1. 扫描每一条规则，如果有 U::=..ab.. |..aVb.. 设置 a=b
2. 扫描，如有 U::=..aV , 设置a<b, 对 b∈ FIRSTVT{V}
3. 扫描，如有 U::=..Va , 设置b>a, 对 b∈ LASTVT{V}
4. 对#特殊处理：E::=#E+T | #T, E::=E+T# | T#

简单概括：

* 所有含 $U::=...aV$ 的规则，a小于$FIRSTVT(V)$中每一元素
* 所有含 $U::=...Va$ 的规则，$LASTVT(V)$中每一元素大于a
* 初始识别符号S两侧加上#，判断优先级

{题目}判断一个文法是否为OPG，构造表，分析句子等。可见习题最后习题5

【注】观察每个格中的符号是否有冲突

#### 素短语

【定义12.6】p277

素短语：文法G的句型的素短语是一个短语，它至少包含有一个终结符号，并且除它自身以外不再包含其他素短语。



CFG、OG、OPG逐层嵌套

OPG无二义性的SR冲突

理想中算符优先文法用于快速找到句柄

* 算符优先文法：先定义优先级，在分析过程中通过比较相邻运算符之间的优先级来确定句型的“句柄”（**最左素短语**）并进行归约。

## 第22-23讲 LR和SLR分析

### 12.4 LR语法分析方法

#### LR分析方法

LR 文法是一种自底向上的分析方法（1965年 D.Knuth 提出）。对LR（k）而言：

* L：从左向右分析 (left to right)
* R：产生“最右推导”(right-most derivation)
* k=1：向前查看“k=1”个符号

从左到右扫描(L)自底向上进行归约(Right-most Derivation)(一定是规范归约）, 是自底向上分析方法的高度概括和集中

LR分析器有三部分组成： 状态栈、分析表、控制程序

* 状态栈：放置分析器状态和文法符号。
* 分析表：由两个矩阵组成，其功能是指示分析器的动作，是移进还是归约，根据不同的文法类要采用不同的构造方法。
* 控制程序：执行分析表所规定的动作，对栈进行操作。

#### 活前缀

规范句型的活前缀：

对于句型$\alpha\beta t$， **β表示句柄**，如果$\alpha\beta=u_1u_2...u_r$，那么符号串u1u2…ui(1≤i≤r) 即是**句型$\alpha\beta t$的活前缀**

* 简单说就是从头到句柄结束的任意前缀

#### LR分析表

##### 状态转移表 (GOTO表)

是一个矩阵：
行---分析器的状态	//（活前缀S0-Sn）
列---文法符号

##### 分析动作表(ACTION表)

行---分析器的状态	//（活前缀S0-Sn）

列---仅终结类符号？

* 告知应当移进？规约？且第几条规则移进/规约

动作分类：

1. 移进(shift)
   ACTION[Si,a] = s （s表示 shift，移进）

   动作: 将a推进栈，并设置新的栈顶状态SjSj= GOTO[Si,a]，将指针指向下一个输入符号

2. 归约(reduce)
   ACTION[Si,a] = rd （s表示 shift，按规则d规约）
   d：文法规则编号
   (d) A→β
   动作: 将符号串β(假定长度为n)连同状态从栈内弹出, 把A推进栈, 并设置新的栈顶状态SjSj= GOTO[Si-n,A]

3. 接受(accept)
   ACTION[Si,#]=accept
   （Si对应的是初始符号的产生式S’→S#对应的状态）

4. 出错(error)
   ACTION[Si,a]=error

GOTO表和ACTION表可以合二为一，p117

##### 表中符号含义

p287

* $S_j$表示把当前输入符号和状态i压进栈；
* $r_j$表示按第j个产生式进行归约；
* acc表示接受；
* 空白表示出错

#### 构造LR(0)的方法

1. 将文法拓广

目的：使构造出来的分析表只有一个接受状态,这是为了实现的方便。

方法：修改文法，**使识别符号的规则只有一条**

2. 根据文法列出所有的项目
3. 将有关项目组合成集合，即DFA中的状态；所有状态再组合成一个集合，即**LR（0）项目集规范族**

##### DFA自动机

关于自动机的说明：

1. 除I0以外,其余状态都是终态,从I0到每一状态的每条路径都识别和接受一个规范句型的活前缀
2. 状态中每个项目对该状态能识别的活前缀都是有效的。
3. 有效项目能预测分析的下一步动作
4. DFA中的状态,既代表了分析历史又提供了展望信息

#### 有效项目

如果存在一个规范推导：
$$
S\nRightarrow \alpha Aw\nRightarrow \alpha\beta_1\beta_2w
$$
则称项目$A\rightarrow \beta_1\cdot\beta_2$对活前缀是$\alpha\beta_1$有效的

#### 相关题目

见最后几次作业，文档最末尾的习题1

#### 求ACTION表

设k为状态编号,E为原文法识别符号，E’为扩充文法识别符号

1、若项目A→α.aβ ∈k,且a ∈Vt ,则置ACTION[k,a] = s (移进）

2、若项目A→ α.∈k, 那么置ACTION[k,a]=rj其中A→ α为文法G’的第j个产生式。

3、若项目E’→E.∈k, 则置ACTION[ k , # ] =accept

4、ACTION表中不能用步骤2~4填入信息的空白格，均置error

LR(0)的局限性 p58

Shift-Reduce冲突、Reduce-Reduce冲突、Shift-Shift冲突？

LR(0)能够处理的情况有限
句柄必须在左侧，没有使用右侧上下文（right context）

#### LR（1）分析法

LR(1)的基本思想：向前偷看一个字符：LR（0） → LR（1）通过“偷看”一个右侧符号，在遇到冲突时辅助决定

思路：将状态区分的更加细致，构造LR(1)的状态机

优势：功能强大！任何LR(0)、LL(1)、确定型CFL、LL(k)、LR(k)都有LR(1)的等价文法

主要问题：状态爆炸！实用性差！

#### SLR（1）：简单LR分析法

基本思想：兼有LR(0)和LR(1)的优点，放弃一些精度。在LR(0)的基础上，只针对冲突进行处理。当发生 S-R冲突时，根据FOLLOW集合确定S还是R

SLR求ACTION表
1、求出文法每个非终结符的FOLLOW集合

2、若项目A→α.aβ ∈k,且a ∈Vt ,则置ACTION[k,a] = s (移进）

3、若项目A→ α.∈k, 那么对输入符号a,若a∈FOLLOW(A),则置ACTION[k,a]=rj。其中A→ α为文法G’的第j个产生式。

4、若项目E’→E.∈k, 则置ACTION[ k , # ] =accept

5、空白格，均置error

* 与LR（0）一些区别：lr0对任意规约r，SLR仅对follow中的Vt规约

#### LALR分析

LALR分析：Lookahead 1 + LR 0

#### LR分析小结

LR分析：从左到右扫描(L)自底向上进行归约(R)(是规范归约）, 是自底向上分析方法的高度概括和集中

##### 优缺点

1) 适合文法类足够大
2) 分析效率高
3) 报错及时
4) 可以自动生成
5) 手工实现工作量大

##### 分析表的种类

1. SLR分析表(简单LR分析表)

   构造简单，最易实现，大多数上下文无关文法都可以构造出SLR分析表，实用价值高

2. LR分析表(规范LR分析表)
   适用文法类最大，几乎所有上下文无关文法都能构造出LR分析表，但其分析表体积太大，实用价值不大

3. LALR分析表(超前LR分析表)
   这种表适用的文法类及其实现难度上在SLR, LR(1) 两种之间，具有实用价值。

#### 关于LR（k）的其他故事

【Q】LR（0）, LR（1）, SLR（1）, LALR（1）文法有二义性吗？

* 定义上看，LR(0), LR(1), LR(k), SLR(1), LALR(1)等，要求构造出来的分析表是“确定性”的，也就是分析表不允许存在冲突

* 因而分析过程是确定的，产生“最右推导”
* 均无二义性（可见下面的图—Unambiguous CFG）

包含关系（p106）

![image-20211207152946747](编译技术 笔记.assets/image-20211207152946747.png)

加入LL（1） p107

![image-20211207153211995](编译技术 笔记.assets/image-20211207153211995.png)

加入OG p110

![image-20211221171505637](编译技术 笔记.assets/image-20211221171505637.png)

## 第24讲 编译程序生成方法和工具

对应书第16章——编译程序生成方法和工具。本章不重要

### 16.1 编译程序的书写语言

#### 书写语言

* 机器语言或汇编语言
  * 主要优点：编出来的程序效率高。
  * 主要缺点：编程效率低，可读性差，不便于修改和移植。
* 高级程序设计语言已基本取代汇编语言
  * 优点：编程效率高，可读性好，利于移植。
  * 缺点：编译程运行效率较低。

#### 自编译性

自编译性：如果一个高级语言能用来书写自己的编译程序，则该语言具有自编译性，并称该语言为自编译语言。

两点说明：
1. 自编译性是语言特征
2. 自编译语言除可编写编译自己的编译程序外，也可用来编写其他高级语言的编译程序。
（例如：用C语言写一个 PL/0 的编译器）
3. 自编译性不是绝对的，只是强弱不同

### 16.2 自展

利用高级语言的自编译性，还可以通过自展方式生成语言的编译程序。

### 16.3 移植

交叉编译

移植：将某台机上的成熟软件移植到另一台机器上，也就是将宿主机上的软件移植到目标机上。

* 具有自编译性的高级语言来书写程序，则移植是方便的。

移植步骤：
1. 将L. L分为两部分：
一部分与机器无关 F.L 一部分与机器有关 A.L
∴ L. L = F.L+ A.L
2. 用语言L改写与具体机器有关的部分（增加后端）
3. 第一次编译
4. 第二次编译（交叉编译）

### 16.4 编译程序的生成工具

目前还没有一个系统能自动生成整个编译系统。

有词法分析器的自动生成器和语法分析器的自动生成器。

* 词法分析器生成器 LEX、FLEX
* 语法分析器生成器：YACC ( YET ANOTHER COMPILER - COMPILER )

## 期末复习知识点

作业与知识点的简单整理

#### 1.编译的基本概念

##### 基本概念

* 编译阶段、编译翻译的区别

> 名词解释,编译五个过程,前后端(作业一)

#### 2.文法和语言

##### 文法概念

* 语言、文法；分类体系，句子、句型、短语、简单短语和句柄的概念

> 语法树，推导，符号串，集合，语言（作业二）

##### 文法构造

* 给定语言特征，构造文法

> 作业三p38: 2, 3, 4

##### 构造并分析语法树

* 给定句子、句型，给出制定要求的推导序列和语法树

> 短语,句柄,二义性,分析句子(作业三)

#### 3.词法分析

##### 正则表达式相互转换,等价证明

* 给定 r1、r2，证明等价性

> p254: 1

##### 由正则文法，正则表达式构造DFA

* 给定正则表达式，构造 NFA，确定化与极小化

> 左线性文法,右线性文法, NFA构造, DFA确定化, DFA最小化(作业四, p254: 2, 3, 4)

##### 由DFA构造正则表达式,正则文法

* 通过 DFA 写文法

> 左线性文法，右线性文法（作业四,作业五)

#### 4.语法分析

##### 自顶向下分析法

* 理解自顶向下分析的要点，给定句子、句型，给出分析过程，给定文法，会改写文法，写递归下降程序

> 消除左递归,消除回湖(作业六)

##### LL1分析法求FIRST集

> 作业七

##### LL1分析法求FOLLOW集

> 作业七

##### LL1分析法构造分析表,判断二义性,推导句子

* 给定文法，判断是否是 LL(1)文法，构造分析表；给定句子写出 LL(1)推导过程

> 作业七

#### 5.符号表管理

##### 画符号表、运行栈

* 给定程序片断，能够准确绘制栈式符号表，理解数组及数组模板，能够正确处理函数形参；理解哈希表加速结构

> 作业八

#### 6.运行时存储组织及管理

##### 静态存储分配

* 给定程序片断，能够正确计算变量偏移地址，并登记符号表

##### 动态存储分配,运行栈状态

* 给定程序片断，绘制运行栈，能理解 活动记录、 调用链（prev abp）和变量索引链（display 区）、函数参数传递机制

> 作业九 

#### 7.中间表示与错误处理

##### 写四元式

* 给定语言片断，写出四元式（或三地址式）表达序列

> 作业十

##### 写逆波兰表达式

* 给定语言片断或表达式，写出逆波兰式；理解基本控制流的逆波兰表达

> 作业十

##### 画DAG图/抽象语法树

* 给定语言片断或表达式，写出抽象语法树表达；理解语法树表达与逆波兰表达的关联

> 作业十

#### 8.代码制导翻译

##### 翻译文法,求对偶

* 理解翻译文法与语法制导翻译概念；给定翻译文法，列出语法制导翻译的对偶

> 作业十一: p166: 1, 2, 3, 4, 5

##### 语法制导,属性翻译文法,自顶向下语法制导翻译

* 理解两类属性的传递过程，理解动作函数嵌入递归下降的过程

> 作业十一: p180: 2, 3,作业十三

#### 9.代码优化

##### 基本块划分与控制流图构建

* 给定语言片断，划分基本块，绘制控制流图（注意增加开始块和退出块）

> 作业十四:1

##### DAG 法消除局部公共子表达式

* 给定基本块内四元式表达，构造 DAG，根据 DAG 启发式输出消除局部公共子表达式的四元式

> 作业十四: 2, 3

##### 活跃变量分析

* 理解数据流方法原理，理解迭代计算过程，理解 def、use、out 、 in 的计算 ， 能基于def-use 分析活跃变量，根据定义点的活性分析冲突，绘制冲突图

> 作业十五:4

##### 到达定义数据流

* 理解数据流方法原理，理解迭代 计 算 过 程 ， 理 解reaching-definition 、 gen 、kill、in、out 的计算

> 作业十五: 5

##### 使用定义链数据流分析

* 理解数据流方法原理，理解迭代计算过程，理解使用-定义链中的数据流及其 gen、kill、in、out 的计算，并分析变量冲突，绘制冲突图

> 作业十六

#### 10.目标代码生成

##### 指令集架构

* 理解四类指令结构及其区别

> 作业十七:1

##### 地址空间及分析

* 理解给定目标体系结构下，运行时地址空间分配，理解函数调用时的参数传递与活动记录，理解体系结构相关的寄存器使用约定与函数调用约定

> 代码区,静态数据区,动态内存区,运行栈(作业+七: 4)

##### 寄存器分配及其算法

* 理解全局寄存器、临时寄存器分配的区别和对象；给定程序片断，能够在构造冲突图的基础上，通过图着色方法分配全局寄存器；理解临时寄存器池的分配原则

> 临时寄存器与全局寄存器,引用计数,图着色等(作业十七:5,6)

#### 11.算符优先分析

##### 写算法优先分析表和算符优先矩阵分析过程

* 理解算符优先级的计算三原则；给定文法能够构造算符优先关系矩阵；能判定给定文法是否为 OPG；给定句子或句型，基于分析表写出分析过程；理解素短语概念

> 作业十八

##### FIRSTVT，LASTVT集合构造

#### 12.LR分析法

##### 活前缀

* 理解句柄、规范句型和规范句型活前缀概念，给定文法和句子、句型，找出所有活前缀

> 作业十九：12-3

##### LR分析原理及有效项目集

* 理解 LR 分析基本原理，理解项目集的概念，熟悉项目集闭包的计算，GOTO 计算，有效项目和有效项目集概念

> 作业十九:12-4

##### LR0分析表构造与分析过程

* 给定文法，构造 LR(0)分析表，能判断给定文法是否为 LR(0)文法；给定句子或句型，依据构造的分析表给出分析过程

> Action, Goto, 状态图(作业十九: 12-5: 1, 2,4)

##### SLR状态转移图和SLR分析表

* 理解 SLR(1)与 LR(0)的区别，理解 SR 冲突、RR 冲突；了解 SLR 通过 Follow 集消解冲突的原理；给定文法，构造SLR(1)分析表，判断文法是否为 SLR(1)文法，给定句子或句型，依据构造的分析表给出分析过程

> 作业二十

## 习题课

### 习题1 构造LR(0)项目集

* 先判断初始符号S是否需要增广
* $B\rightarrow \epsilon$等情况仅有$B\rightarrow .$一种项目集写法

![image-20211219145815966](编译技术 笔记.assets/image-20211219145815966.png)



### 习题2 运行栈时状态

* PASCAL允许function嵌套
* 看表头是否给了”层次“，决定画不画右边的表
* 已经弹出的行可以不写

![image-20211219145826011](编译技术 笔记.assets/image-20211219145826011.png)

* display区，显示追踪层级
* prevabp追踪谁调用我
* 注意参数、局部数据也存入栈中
* ret_addr不应该指具体的，因为本质上应该指向代码区的某个位置
* 现在只是在编译过程中的准备参数阶段，还未实际运行，需要调用到最外的watch函数，不调用2次
* 请问如果在program的begin end里声明一个变量，那么应该把变量放在哪里(这算全局吗？与PASCAL语言性质有关，在开始var定义的即为局部变量

![image-20211219145837964](编译技术 笔记.assets/image-20211219145837964.png)

### 习题3 DFA

* 引入多个状态的标准做法没错，但之后确定化、极小化时工作量大，所以尽可能最开始就简化、用更少状态写NFA

* 记得读取一个字符后的状态集合，**再做一次e-闭包**！
* 确定化为DFA最后得到的状态中，包含原终态的均为终态
* 确定化为DFA后，可用简单例子检查下是否是对的
* 最小化。画下三角N*N状态的二维表
* 最小化通常不用写太细，如xx和xx为什么不可合并，具体看题目要求，画对表即可

![image-20211219152921036](编译技术 笔记.assets/image-20211219152921036.png)

### 习题4 属性翻译文法

* 检查初始符号S是否需要增广，增加一个S’，保证只打印1次
* @init初始化计数器n=0（不需要）；@pr函数打印输出；@inc函数赋值计数加一
* 不建议用全局变量，核心是把传递关系表达出来

![image-20211219154946827](编译技术 笔记.assets/image-20211219154946827.png)

（2）打印每个a的嵌套深度：

![image-20211219155005032](编译技术 笔记.assets/image-20211219155005032.png)

* 【注】似乎还应注意，每个非终结符L、S等的继承、综合属性要一致

### 习题5 算符优先分析法

证明文法G[S]不是算符优先文法

* 本质是画算符分析矩阵，是否有同一个格内同时有>和<冲突
* 算每个非终结符的FIRSTVT和LASTVT两个集合
* 对于aW情况，a小于FIRSTVT(W)所有；Wa情况，LASTVT(W)中所有大于栈外的a
* 注意加上#处理
* 此题注意：LASTVT（M）是不是应该还有一个c
* 理论上此题还要增广，

#的算法：（书p271有计算）

初始符号#bMb#，#b#，代入计算。另注意#与#相遇时状态变为Done

![image-20211219161724700](编译技术 笔记.assets/image-20211219161724700.png)

### 习题6 DAG图优化基本块

* 进入顺序是没有root的节点一个个加进去，反向生成表达式
* 一个问题是重复变量t1、t6中输出谁，书上含糊，可与活性分析相关联，留活跃、有用的，否则还得给活跃的赋值t6=t1
* 变量重复定义的情况，要处理变量重命名情况，需改名、加下标，两个变量不同
* 节点表可写可不写吧，我觉得能画出图、正确输出就满意了
* 【注】此处对于重复的t5、t6用的是公共子表达式删除的手段？

![image-20211219162038194](编译技术 笔记.assets/image-20211219162038194.png)

* 数据流、使用链、网络冲突图
* reaching defination：从上向下计算，in计算out
* def/use：看先定义后使用，还是反之。从下向上、反着计算，out算in
* 使用-定义链：从in算out。看每个基本块内，追踪一个定义的定义、使用位置
* 需要看清楚具体要求用哪种方式画冲突图？
* 活前缀含义：从头开始，一直到包含句柄的全部前缀

### 其它

* 无可奉告题型，跟小测的题目类型，差不多基本的概念应当掌握，至于是填空题、选择题？考已经无所谓了

* 提高准确率，快速算法应当算的足够快
