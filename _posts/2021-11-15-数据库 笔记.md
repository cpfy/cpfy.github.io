# 数据库系统原理

## 第四章 数据库的安全性

**数据库的安全性**：是指保护数据库以防止不合法的使用所造成的数据泄漏、更改和破坏。

### 数据库安全性控制

#### 常用方法与技术

* 用户身份鉴别
* 多层存取控制
* 审计
* 视图和数据加密

#### 存取控制

存取控制可以分为：

* **自主存取控制**(discretionary access control，简称DAC)。用户对于不同的数据对象拥有不同的存取权限，不同的用户对同一对象也有不同的权限，而且用户还可以将其拥有的权限转授给其他用户。
* **强制存取控制**(mandatory access control，简称MAC)。每一个数据对象被标以一定的密级，每一个用户也被授予某一个级别的许可证。对于任一个对象，只有具有合法许可证的用户才可以存取。

#### 角色与用户组

为了管理数据库特权的方便，数据库还支持角色和用户组的概念。

* **角色**是一组权限的集合，可以把它授予用户或其他角色。当把某个角色授予用户（或角色）或从用户（或角色）处收回时，就同时授予或收回了该角色代表的全部权限。
* **用户组**是一组具有相同特性用户的集合。在授权或收回权限时，可以以用户组为单位进行。

### SQL语言权限操作

#### 授予权限

* 每一个用户都拥有自己定义的数据库对象如（基本表、视图等），除了他自己和拥有DBA权限的用户以外，其他用户都不能访问这些数据库对象。如果想和其他用户共享其中一部分数据库对象，就必须将这些数据库对象上的部分或全部权限授予其他用户。其语法格式为：

```sql
Grant ALL| <权限> [{,<权限>}]
       On <表名> | <视图名> [{,<表名> | <视图名>}]
       To {<用户> [{, <用户>}] | public}
       [With Grant Option]

```

#### 回收权限

* 收回权限时，若该用户已将权限授予其它用户，则也一并收回。

```sql
Revoke ALL|<表级权限> [{,<表级权限>}] 
  On <表名>|<视图名> [{,<表名> | <视图名>}] 
  From {<用户>[{,<用户>}]|PUBLIC}例：收回Liming对Student表的全部权限
Revoke ALL On Student From Liming;
```

## 第五章 数据库的完整性

### 完整性定义

**数据库的完整性**：指数据的正确性和相容性

* 正确性是指数据应具有合法的类型，如数值型的字段只能含有0~9，不能包含其它符号；更进一步，数据还应在有效的取值范围之内，如一年最多只有12个月，不能出现13个月。
* 相容性是指表示同一个事实的两个数据应该相同，如一个人不应当存在两个年龄。数据库能否保持完整性关系到数据库系统是否能够真实的反映现实世界，因此维护数据库的完整性十分重要

### 完整性约束条件

**数据库完整性约束条件**：施加在数据库数据之上的语义约束条件

完整性约束条件作用的对象可以是关系、元组、列三种

* 列约束主要是列的类型、取值范围、精度等约束条件。
* 元组的约束是元组中各个字段间联系的约束。
* 关系的约束是若干元组间、关系集合上以及关系之间的联系的约束

涉及这三类对象的完整性约束又可分为静态约束和动态约束

* 静态约束是指数据库每一确定状态（在某一时刻数据库中的所有数据实例构成了数据库的一个状态）时，数据对象所应满足的约束条件，它是反映数据库状态合理性的约束。
  * 固有约束
    指数据模型固有的约束，如关系的属性应当是原子的。
  * 隐含约束
    指隐含于数据模式的约束，一般用DDL语句说明，并存于数据字典中。如实体完整性约束。
  * 显式约束
    指固有约束，隐含约束之外，依赖于数据的语义和应用，需要显式定义的完整性约束
* 动态约束是指数据库从一种状态转变为另一种状态时，新、旧值之间所应满足的约束条件，它是反映数据库状态变迁的约束

### 数据库的完整性控制机制

#### 数据库（RDBMS）的完整性控制机制的功能

书的版本（p156）

1. 提供定义完整性约束条件的机制
2. 提供完整性检查的方法
3. 进行违约处理

PPT版本（第四章-p47）

1. 定义功能，提供定义完整性约束条件的机制。
2. 检查功能，检查用户发出的操作请求是否违背了完整性约束条件。
3. 违约响应，若违背了完整性约束条件，则采取一定措施来保证数据的完整性。

#### 完整性检查的时机

* 立即执行约束：指在执行用户事务的过程中，在一条语句执行完后立即进行完整性约束的检查。若违背了完整性约束，系统将拒绝该操作。
* 延迟执行约束：指在整个用户事务执行完毕后，再进行完整性约束的检查，若正确方允许提交事务。若违背了完整性约束，系统将拒绝整个事务。

#### 完整性规则

一条完整性规则可以用一个五元组（D，O，A，C，P）来描述，其中：

* D（Data）约束所作用的数据对象
* O（Operation）触发完整性检查的数据库操作，即当用户发出什么操作请求时需要检查该完整性规则，是立即检查还是延迟检查。
* A（Assertion）数据对象必须满足的断言或语义约束。
* C（Condition）选择A作用的数据对象值的谓词。
* P（Procedure）违反完整性规则时触发的过程。

#### 隐含约束

* 实体完整性和其他用DDL定义的约束：Insert 或者Update时检查。若违反，则拒绝相应操作

* 参照完整性：Insert、Update、Delete时检查

  | 被参照表           | 参照表             | 违约处理               |
  | ------------------ | ------------------ | ---------------------- |
  | 可能破坏参照完整性 | 插入元组           | 拒绝                   |
  | 可能破坏参照完整性 | 修改外码值         | 拒绝                   |
  | 删除元组           | 可能破坏参照完整性 | 拒绝/级联删除/设为空值 |
  | 修改主码值         | 可能破坏参照完整性 | 拒绝/级联更新/设为空值 |

#### 显式完整性约束的说明

* 用过程说明约束
* 用断言说明约束
* 用触发器表示约束

## 第六章 关系数据理论

### 候选码的求解

ppt中缺失此部分（摘自：https://blog.csdn.net/zhang1213885531/article/details/80961983）

#### 属性分类

对于给定的关系R（A1，A2，…An）和函数依赖集F，可将其属性分为4类：

* L类  仅出现在函数依赖左部的属性。
* R 类  仅出现在函数依赖右部的属性。
* N 类  在函数依赖左右两边均未出现的属性。
* LR类  在函数依赖左右两边均出现的属性。

#### 定理与推论

* 定理：对于给定的关系模式R及其函数依赖集F，若X（X∈R）是L类属性，则X必为R的任一候选码的成员。
* 推论：对于给定的关系模式R及其函数依赖集F，若X（X∈R）是L类属性，且X+包含了R的全部属性；则X必为R的唯一候选码。
* 定理：对于给定的关系模式R及其函数依赖集F，若X（X∈R）是R类属性，则X不在任何候选码中。
* 定理：对于给定的关系模式R及其函数依赖集F，若X（X∈R）是N类属性，则X必包含在R的任一候选码中。
* 推论：对于给定的关系模式R及其函数依赖集F，若X（X∈R）是L类和N类组成的属性集，且X+包含了R的全部属性；则X是R的唯一候选码。

#### 算法步骤

1. 将R 的所有属性分为L、R、LR 和N 四类，并令X 代表L、N 类，Y 代表LR 类。 
2. 求X+。若X+包含了R 的全部属性，则即为R 的唯一候选码，转（5）；否则，转（3）。
3. 在Y 中取一属性A，求（XA）+ ，若它包含了R 的全部属性，则是候选码，转（4）；否则，调换一属性反复进行这一过程，直到试完所有Y 中的属性。 
4. 如果已找出所有候选码，则转（5）；否则在Y 中依次取2 个、3 个、…，求它们的属性闭包，若其闭包包含R 的全部属性，则是候选码。 
5. 结束

#### 求解候选码例题

【第六章作业-第4题】设有关系模式$R(ABCDE)$，其函数依赖集$F=\{A\rightarrow BC, CD\rightarrow E, B\rightarrow D, E\rightarrow A\}$

* 一种解法：A、B、C、D、E均在LR中，逐个尝试A-E，发现A与E可为候选码；

  对BCD两两组合尝试，发现$(B,C)$与$(C,D)$均可构成候选码，有依赖$B\rightarrow D$故不考虑$(B,D)$

* 候选码有4个：即$A,E,(B,C),(C,D)$

### 函数依赖集的最小覆盖

#### 定义

函数依赖集的等价性：函数依赖集F，G，若F+= G+，则称F与G等价

最小依赖集（最小覆盖）：满足下列条件的函数依赖集F称为最小覆盖，记作$F_m$：

+ F中任一函数依赖的右部仅含有一个属性
+ 不存在传递函数依赖：F中不存在这样的函数依赖$X\rightarrow A$，使得F与$F-\{X\rightarrow A\}$等价。
+ 不存在部分函数依赖：F中不存在这样的函数依赖$X\rightarrow A$，在X中有真子集Z，使得F与$F-\{X\rightarrow A\} \cup \{ Z \rightarrow A \}$等价

#### 求解算法

算法：（求解函数依赖集F的最小覆盖$F_m$）

1. 【将F中的所有依赖右边化为单一元素】：若$X\rightarrow Y$且$Y=A_1A_2...A_k(k\geq 2)$，用诸$X\rightarrow A_i$代替Y；
2. 【去掉F中的所有依赖左边的冗余属性】：逐个检查F中各函数依赖$X\rightarrow A$，令$G = F-\{X\rightarrow A\}$，若$A\in X_G^+$，则从F中去掉该函数依赖。
3. 【去掉F中所有冗余依赖关系】：逐个检查F中各函数依赖$X\rightarrow A$，设$X = B_1...B_m$，逐个考查$B_i$，若$A\in (X-B_i)_F^+$，则以$(X-B_i)$取代$X$

### 模式分解

#### 分解目标

* 无损连接：可以通过自然连接恢复到原来的关系；
* 保持函数依赖：同时也保持了原关系的函数依赖；
* 达到更高级范式：消除了原关系的异常。如分解三达到<BC范式>

#### 模式分解的算法

一般定义： r = {R1<U1 , F1> , R2<U2 , F2>, … , Rn<Un , Fn>}是R<U , F>的一个分解，r是R<U , F>的一个关系。定义mr(r) =  ∏Ri(r) ,若对于R<U , F>的任一个关系r，都有r = mr(r)，则称r是R<U , F>的一个无损连接分解。

#### 无损连接判别

##### 方法一：一个填表的方法

算法：（判别一个分解的无损连接性）

1. 填矩阵$a_i,b_{ij}$
2. 按所有依赖操作对应列，改变元素。如果在某次更改之后，有一行成为a1, a2 , … , an 。则算法终止， $\rho$为无损分解，否则为有损分解
3. 扫描后若无变化，终止；否则返回第二步

举例p65-p73

示例：$U=\{A,B,C,D,E\}, F={AB\rightarrow C, C\rightarrow D,D\rightarrow E},\rho ={(A, B, C), (C, D), (D, E)}$

##### 方法二：无损连接定理

定理：若$U_1 \cap U_2 \rightarrow U_1(or \ U_2)$。若满足，可判断是无损连接

填表法可证明定理（第二行为a1-a3）

|        | $U_1 \cap U_2$ | $U_1 - U_1 \cap U_2$ | $U_2 - U_1 \cap U_2$ |
| ------ | -------------- | -------------------- | -------------------- |
| R1(U1) | $a_1$          | $a_2$                | $b_{13}$             |
| R2(U2) |                | $a_2$                | $a_3$                |

#### 一些分解算法

算法：（达到3NF且保持函数依赖的分解）

1. 对$R<U,F> $中的函数依赖集F进行“极小化处理”（处理后得到的依赖集仍记为F）。
2. 找出不在F中出现的属性，将它们构成一个关系模式，并从U中去掉它们(剩余属性仍记为U)。
3. 若有$X\rightarrow A \in F$，且$XA=U$，则$\rho =\{R\}$，算法终止。
4. 否则，对F按具有相同左部的原则进行分组（设为k组），每一组函数依赖Fi‘所涉及的全部属性为Ui。若Ui  Uj （i≠j） ，就去掉Ui 。由于经过了步骤2，故U =     Ui ，于是 = {R1<U1 , F1> , … , Rk<Uk , Fk>}是R<U , F>的一个保持函数依赖的分解，并且每个Ri<Ui , Fi> 3NF

例子p78

算法：（达到3NF且同时保持无损连接与函数依赖的分解）——见p80

算法：（达到BCNF无损连接分解算法）——见p82



## 第七章 数据库设计

### 基本

#### 设计概述

略

#### 设计特点

* 三分技术，七分管理，十二分基础数据
* 数据库设计与硬件、软件等紧密相关
* 数据库设计要把结构（数据）设计和行为（处理）设计密切结合起来。

#### 设计方法

手工试凑方法：一堆缺点（p8），仅适合小系统

规范化设计方法

特点

* 分步进行
* 反复性
* 试探性

自动数据库设计工具

#### 数据库生命周期

需求分析

调查情况、熟悉业务、预测

概念结构设计
逻辑结构设计
物理结构设计
数据库的实施
数据库运行与维护



数据字典是系统中各类数据描述的集合，是进行详细的数据收集和数据分析所获得的主要成果



概念结构设计

将需求分析得到的用户需求抽象成为信息结构即概念模型的过程

### 概念设计

#### 概念设计的策略

* 自顶向下：首先定义全局概念结构的框架，然后逐步细化
* 自底向上：首先定义各局部应用的概念结构，然后将它们集成起来，得到全局概念结构。
* 逐步扩张：首先定义最重要的核心概念结构，然后向外扩充，以滚雪球的方式逐步生成其他概念结构，直至总体概念结构
* 混合策略：即将自顶向下和自底向上相结合

视图综合设计方法

局部视图设计

* 确定局部实体
* 确定局部实体之间的联系（包括超类/子类联系）
* 构造局部ER图

局部视图设计的关键在于实体和属性的正确划分。其主要手段为：

* 分类：定义某一概念作为现实世界中一组对象的类型。这些对象具有某些共同的特性和行为。它抽象了对象值和型之间的“is member of”的语义。
* 聚集：定义某一类型的组成成分，它抽象了对象内部类型和成分之间“is part of”的语义。
* 概括

### 逻辑结构设计

#### 局部视图设计

#### 集成ER图

* 合并
  解决各局部ER图之间的冲突，将各局部ER图合并起来生成初步ER图。
* 修改和重构
  消除不必要的冗余，生成基本ER图。

#### 消除各局部ER图的冲突

* 命名冲突
  * 同名异义
    即同一名字在不同的局部ER图中表示不同的概念。

  * 异名同义

    即同一个概念在不同的局部ER图中使用了不同的名字。

* 结构冲突

  结构冲突是模式结构的冲突。它指相同的概念在不同的局部ER图中使用不同的概念结构来表示

* 值域冲突

* 约束冲突

#### 实体间联系的转换



#### 关系模式的优化

优化关系模式的两种方法：

##### 水平分解（减少记录行数）

把经常使用的那一部分数据分解出来作为一个关系，其他数据作为另一个关系

做法：把关系的元组分为若干子集合，定义每个子集合为一个子关系

##### 垂直分解（减少属性数）

经常在一起使用的属性从R中分解出来形成一个子关系模式

做法：把关系模式R的属性分解为若干子集合，形成若干子关系模式

##### 逆规范化

如果经常需要对多个关系进行连接操作，且大多数操作为查询操作，更新很少，则可以考虑将这些关系合并为一个关系

##### 设计子模式

根据局部应用的需求，结合具体DBMS的特点，设计用户外模式

#### 关系存取方法

* 索引存取方法
* 聚簇存取方法
* HASH存取方法

## 第九章（附） 数据库存储（文件结构）

### 存储介质简介

#### 磁盘

简单介绍

#### RAID

* RAID0：即没有容错设计的条带硬盘阵列（Striped Disk Array without Fault Tolerance），以条带形式将RAID组的数据均匀分布在各个硬盘中
* RAID 1 定义：又称镜像（Mirror），数据同时一致写到主硬盘和镜像硬盘
* RAID 2 采用早期的海明码校验组成硬盘阵列
* RAID 3即带有校验的并行数据传输阵列（Paralleled transfer with parity），数据条带化分布在数据盘中，同时使用专用校验硬盘存放校验数据 
* RAID 4是带有共享校验硬盘的独立数据盘
* RAUD 5与RAID 3机制类似，但校验数据均匀分布在各数据硬盘上，RAID成员硬盘上同时保存数据和校验信息
* RAID 6 是带有两个独立分布式奇偶校验方案的独立数据硬盘（Independent data disks with two independent distributed parity schemes）。广义上讲，能够允许两个硬盘同时失效的RAID级别统称为RAID 6

### 缓冲区调度

多数操作系统采用最近未使用(LRU)的缓冲区替换策略

特点：相对于操作系统中的虚拟存储系统,缓冲区管理支持更加复杂的功能

### 数据库文件结构

#### 定长记录

定长记录文件-记录的长度是固定的

简单方法:
记录i 从字节n * (i – 1)开始存储, 其中n 是记录大小.
存在的问题
记录存取简单, 但记录可能跨块，读写需要两个块
变化: 不允许记录跨越块边界

删除方式：自由链表

#### 变长记录

变长记录文件-文件中能够容纳不同长度的、不同类型的记录

### 文件中的记录组织

不同的组织方式

* 堆 – 记录可置于文件中的任何有空间的地方
* 顺序 – 记录按顺序存储, 基于每条记录在搜索码上的值
* 散列 – 对记录的某属性计算散列函数; 计算结果决定该记录应该置于文件的哪个块中

#### 顺序文件组织 

维护记录的物理顺序代价高

* 删除 – 利用指针链
* 插入 – 确定待插入记录的位置
  若有自由空间则在该处插入
  若无自由空间, 插入到溢出块
  两种情况都要更新指针链
  如果溢出块中数据很多，则逻辑顺序和物理顺序存在很大的不同，可能导致数据访问中I/O操作过多
* **需要不时重组文件以恢复物理存储顺序，重组代价高**

#### 聚簇文件组织

* 简单的文件结构将每个关系存储在一个单独的文件中
* 利用聚簇文件组织可以将多个关系存储在一个文件中

#### 关系数据库的文件选择

* 存储关系到一个文件
  * Advantage
    充分利用OS所提供的功能，减少DMBS的处理代价
  * Disadvantage
    DBMS的某些优化策略不支持
* 存储多个关系到一个文件（多采用）
  * Advantage
    DBMS支持某些优化策略，可以在文件中设计复杂的结构
  * Disadvantage
    增加了数据库的大小和复杂性

#### 数据字典的存储

数据字典(也称为系统目录) 保存元数据: 即关于数据的数据

## 第十章（附） 索引

索引评价度量

### 索引分类

有序索引：稠密索引文件

有序索引：稀疏索引文件

#### 多级索引

为减少对索引记录的磁盘存取次数, 将主索引视为存储在磁盘上的顺序文件并为它建立一个稀疏索引.
外索引 – 主索引的稀疏索引
内索引 – 主索引文件
如果外索引仍太大而不能放入内存, 还可再为它创建另一层索引, 如此类推

* 辅助索引
* B+-树索引文件
* 插入、删除
* Hash数据索引

## 第九章 查询优化

查询处理的基本步骤：

* 语法分析与翻译
* 优化
* 执行查询语句



查询优化的步骤

* 将查询转换成某种内部表示，通常是语法树。
* 根据一定的变换规则，把语法树转换为优化形式。
* 选择低层的操作算法。
* 生成查询执行计划（也称查询执行方案，是由一系列内部操作构成的）。

基本运算的实现

每一基本的代数运算都有多种不同的实现算法。
适用于不同的情况
等值条件，范围条件
数据是聚集的，数据是非聚集的
相关属性上有索引，相关属性上没有索引
执行代价不同



选取运算的实现算法

* 全表扫描方法：依次访问表的每一个块，对于每一个元组，测试它是否满足选择条件。效率低，但对关系的存储方式没有要求，不需要索引。适用于任何选择条件。
* 折半扫描: 
* 索引扫描

连接操作的实现 

嵌套循环方法
排序-合并方法
索引连接方法
HASH join方法

#### 查询代价的度量

查询代价：查询处理对各种资源的使用情况

* 总代价=I/O代价+CPU代价+通信开销

* 一个重要的影响因素：主存中缓冲区的大小M。（如多次运行同一算法，开始极慢，之后由于数据读入缓存，执行时飞一般的速度）



#### 查询优化的必要性

一个例子

例：求选修了课程C2的学生姓名
SELECT Student.Sname
FROM Student, SC
WHERE Student.Sno=SC.Sno
AND SC.Cno='2';

##### 查询1

$$
Q_1=\prod_{Sname}(\sigma_{Student.Sno=SC.Sno}\and SC.Cno='2'(Student\times SC))
$$

##### 查询2

$$
Q_1=\prod_{Sname}(\sigma_{SC.Cno='2'}(Student\bowtie SC))
$$



##### 查询3

$$

$$



两个表达式等价：产生的结果关系具有相同的属性集和相同的元组集。



关系代数等价变换规则

1-2: 连接、笛卡尔积的交换律、结合律
3： 合并或分解投影运算
4： 合并或分解选择运算
5-8：选择运算与其他运算交换
5，9，10： 投影运算与其他运算交换



查询优化的一般准则

* 选择运算应尽可能先做。目的：减小中间关系。
  在执行连接操作前对文件适当进行预处理
  排序
  在连接属性上建立索引
  投影运算和选择运算同时做。目的：避免重复扫描关系。
  把投影运算与其前面或后面的双目运算结合起来。目的：减少扫描关系的遍数。



查询树



### 性能优化

对数据库性能影响最大的是数据库的设计和开发。通常，所谓的性能优化实际上就是重新开发数据库系统中设计的很糟的那一部分。 

优化准则

 花费尽可能多的努力来设计数据库模式，所有的优化都要基于数据库模式。
 集中精力优化运行最频繁的代码，而不是那些运行最慢的代码。
 在升级硬件之前进行优化。即使在速度快的服务器上，坏代码仍旧是坏代码。

等等等等

负载测试

数据负载测试
只有当数据量超出了服务器内存容量好几倍的时候，才能够对数据库模式和查询进行负载测试。 
用户负载测试

只有当使用大量的用户来测试数据库时才有可能发生锁争用，而锁争用会导致严重的性能问题。

清除测试的影响
数据库已经经过优化，它可以智能地将数据缓存在内存中，而这将会影响到后续测试的结果。因此，测试前要刷新内存，这可以通过停止并重新启动服务器实现。

数据库设计与性能

## 第十章 数据库恢复技术

### 事物

#### 事物定义

事务是用户定义的一个数据库操作序列构成，这些操作要么全做，要么全不做，是一个不可分割的工作单位

* 事务与应用程序是两个概念，一般来说，一个应用程序可以包含多个事务。
* 事务的开始与结束可以由用户显式控制。如果用户没有显式定义事务，则由DBMS按缺省规定自动划分事务。

#### SQL中事务

* 事务以Begin transaction开始，以Commit work或 Rollback work结束。
* Commit work表示提交，事务正常结束。
* Rollback work表示事务非正常结束，撤消事务已做的操作，回滚到事务开始时状态。

#### 事务的特性（ACID）

* 原子性(Atomicity)
  	 事务是数据库的逻辑工作单位，事务中包括的诸操作要么全做，要么全不做。
* 一致性(Consistency)
  	事务执行的结果应当使数据库从一个一致性状态转变为另一个一致性状态。
* 隔离性(Isolation)
  	一个事务的执行不能被其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能相互干扰。
* 持久性(Durability)
  	一个事务一旦提交之后，它对数据库的影响必须是永久的。事务提交后，系统发生故障不能改变事务的持久性。
  	
